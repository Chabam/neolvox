diff --git a/CMakeLists.txt b/CMakeLists.txt
index e7056d3..bd3390e 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -45,12 +45,17 @@ find_package(Qt5 5.3 COMPONENTS
              Gui
              OpenGL)
 
-qt5_add_resources(RESOURCES ./resources/resources.qrc)
+qt5_add_resources(RESOURCES
+  ./resources/resources.qrc
+  ./resources/nodeeditor.qrc
+)
 
 # Unfortunately, as we have a split include/src, AUTOMOC doesn't work.
 # We'll have to manually specify some files
 set(CMAKE_AUTOMOC ON)
 
+file(GLOB_RECURSE HEADERS_TO_MOC include/nodes/internal/*.hpp)
+
 set(CPP_SOURCE_FILES
   src/Connection.cpp
   src/ConnectionBlurEffect.cpp
@@ -78,8 +83,9 @@ set(CPP_SOURCE_FILES
 # If we want to give the option to build a static library,
 # set BUILD_SHARED_LIBS option to OFF
 add_library(nodes
-  ${CPP_SOURCE_FILES}
-  ${RESOURCES}
+    ${CPP_SOURCE_FILES}
+    ${RESOURCES}
+    ${HEADERS_TO_MOC}
 )
 add_library(NodeEditor::nodes ALIAS nodes)
 
@@ -129,20 +135,6 @@ set_target_properties(nodes
     RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin
 )
 
-######
-# Moc
-##
-
-file(GLOB_RECURSE HEADERS_TO_MOC include/nodes/internal/*.hpp)
-
-qt5_wrap_cpp(nodes_moc
-    ${HEADERS_TO_MOC}
-  TARGET nodes
-  OPTIONS --no-notes # Don't display a note for the headers which don't produce a moc_*.cpp
-)
-
-target_sources(nodes PRIVATE ${nodes_moc})
-
 ###########
 # Examples
 ##
diff --git a/external/CMakeLists.txt b/external/CMakeLists.txt
index 8e12fb1..39dbc04 100644
--- a/external/CMakeLists.txt
+++ b/external/CMakeLists.txt
@@ -5,9 +5,3 @@ if(BUILD_TESTING)
     add_subdirectory(Catch2)
   endif()
 endif()
-
-macro(find_package pkg)
-  if(NOT TARGET "${pkg}")
-    _find_package(${ARGV})
-  endif()
-endmacro()
diff --git a/include/nodes/internal/Connection.hpp b/include/nodes/internal/Connection.hpp
index 5f79b38..9e9da72 100644
--- a/include/nodes/internal/Connection.hpp
+++ b/include/nodes/internal/Connection.hpp
@@ -41,12 +41,19 @@ public:
              Node& node,
              PortIndex portIndex);
 
+  // RM : customize specfic data for connection
+  Connection(PortType portType,
+             Node& node,
+             PortIndex portIndex,
+             void* data);
+
   Connection(Node& nodeIn,
              PortIndex portIndexIn,
              Node& nodeOut,
              PortIndex portIndexOut,
              TypeConverter converter =
-               TypeConverter{});
+               TypeConverter{},
+             void* data = nullptr);
 
   Connection(const Connection&) = delete;
   Connection operator=(const Connection&) = delete;
@@ -84,6 +91,10 @@ public:
   void
   removeFromNodes() const;
 
+  // RM : customize specfic data for connection
+  void* data() const;
+  void setData(void* newData);
+
 public:
 
   ConnectionGraphicsObject&
@@ -115,6 +126,8 @@ public:
   NodeDataType
   dataType(PortType portType) const;
 
+  TypeConverter& typeConverter();
+
   void
   setTypeConverter(TypeConverter converter);
 
@@ -123,6 +136,10 @@ public:
 
 public: // data propagation
 
+  void
+  propagateData() const;
+
+  // RM : customize specfic data for connection
   void
   propagateData(std::shared_ptr<NodeData> nodeData) const;
 
@@ -158,6 +175,9 @@ private:
 
   TypeConverter _converter;
 
+  // RM : customize specfic data for connection
+  void* mData;
+
 Q_SIGNALS:
 
   void
diff --git a/include/nodes/internal/ConnectionGraphicsObject.hpp b/include/nodes/internal/ConnectionGraphicsObject.hpp
index 7db498e..eade02c 100644
--- a/include/nodes/internal/ConnectionGraphicsObject.hpp
+++ b/include/nodes/internal/ConnectionGraphicsObject.hpp
@@ -3,6 +3,7 @@
 #include <QtCore/QUuid>
 
 #include <QtWidgets/QGraphicsObject>
+#include "Export.hpp"
 
 class QGraphicsSceneMouseEvent;
 
@@ -15,7 +16,7 @@ class ConnectionGeometry;
 class Node;
 
 /// Graphic Object for connection. Adds itself to scene
-class ConnectionGraphicsObject
+class NODE_EDITOR_PUBLIC ConnectionGraphicsObject
   : public QGraphicsObject
 {
   Q_OBJECT
@@ -75,6 +76,9 @@ protected:
   void
   hoverLeaveEvent(QGraphicsSceneHoverEvent* event) override;
 
+  void
+  mouseDoubleClickEvent(QGraphicsSceneMouseEvent* event) override;
+
 private:
 
   void
diff --git a/include/nodes/internal/ConnectionState.hpp b/include/nodes/internal/ConnectionState.hpp
index 9191267..ad51e93 100644
--- a/include/nodes/internal/ConnectionState.hpp
+++ b/include/nodes/internal/ConnectionState.hpp
@@ -18,7 +18,8 @@ class ConnectionState
 public:
 
   ConnectionState(PortType port = PortType::None)
-    : _requiredPort(port)
+    : _requiredPort(port),
+	  _preview(false)  // MK : manage preview for connections
   {}
 
   ConnectionState(const ConnectionState&) = delete;
@@ -40,6 +41,13 @@ public:
   void setNoRequiredPort()
   { _requiredPort = PortType::None; }
 
+  // MK : manage preview for connections
+  void setIsAPreview(bool isAPreview)
+  { _preview = isAPreview; }
+
+  bool isAPreview() const
+  { return _preview; }
+
 public:
 
   void interactWithNode(Node* node);
@@ -55,6 +63,7 @@ public:
 private:
 
   PortType _requiredPort;
+  bool	   _preview;  // MK : manage preview for connections
 
   Node* _lastHoveredNode{nullptr};
 };
diff --git a/include/nodes/internal/ConnectionStyle.hpp b/include/nodes/internal/ConnectionStyle.hpp
index e37feb0..6c1406c 100644
--- a/include/nodes/internal/ConnectionStyle.hpp
+++ b/include/nodes/internal/ConnectionStyle.hpp
@@ -37,6 +37,10 @@ public:
   QColor selectedHaloColor() const;
   QColor hoveredColor() const;
 
+  QColor groupColor() const;
+  QColor itemColor() const;
+  QColor attributeColor() const;
+
   float lineWidth() const;
   float constructionLineWidth() const;
   float pointDiameter() const;
@@ -51,6 +55,10 @@ private:
   QColor SelectedHaloColor;
   QColor HoveredColor;
 
+  QColor GroupColor;
+  QColor ItemColor;
+  QColor AttributeColor;
+
   float LineWidth;
   float ConstructionLineWidth;
   float PointDiameter;
diff --git a/include/nodes/internal/DataModelRegistry.hpp b/include/nodes/internal/DataModelRegistry.hpp
index eaabe26..4f64f07 100644
--- a/include/nodes/internal/DataModelRegistry.hpp
+++ b/include/nodes/internal/DataModelRegistry.hpp
@@ -19,15 +19,6 @@
 namespace QtNodes
 {
 
-inline
-bool
-operator<(QtNodes::NodeDataType const & d1,
-          QtNodes::NodeDataType const & d2)
-{
-  return d1.id < d2.id;
-}
-
-
 /// Class uses map for storing models (name, model)
 class NODE_EDITOR_PUBLIC DataModelRegistry
 {
diff --git a/include/nodes/internal/FlowScene.hpp b/include/nodes/internal/FlowScene.hpp
index 6d59725..c6f82c4 100644
--- a/include/nodes/internal/FlowScene.hpp
+++ b/include/nodes/internal/FlowScene.hpp
@@ -1,20 +1,19 @@
 #pragma once
 
+#include <QtCore/QJsonDocument>
 #include <QtCore/QUuid>
 #include <QtWidgets/QGraphicsScene>
-
-#include <unordered_map>
-#include <tuple>
 #include <functional>
+#include <tuple>
+#include <unordered_map>
 
-#include "QUuidStdHash.hpp"
-#include "Export.hpp"
 #include "DataModelRegistry.hpp"
+#include "Export.hpp"
+#include "QUuidStdHash.hpp"
 #include "TypeConverter.hpp"
 #include "memory.hpp"
 
-namespace QtNodes
-{
+namespace QtNodes {
 
 class NodeDataModel;
 class FlowItemInterface;
@@ -25,52 +24,53 @@ class ConnectionGraphicsObject;
 class NodeStyle;
 
 /// Scene holds connections and nodes.
-class NODE_EDITOR_PUBLIC FlowScene
-  : public QGraphicsScene
-{
+class NODE_EDITOR_PUBLIC FlowScene : public QGraphicsScene {
   Q_OBJECT
-public:
-
+ public:
   FlowScene(std::shared_ptr<DataModelRegistry> registry,
-            QObject * parent = Q_NULLPTR);
-
-  FlowScene(QObject * parent = Q_NULLPTR);
+            QObject* parent = Q_NULLPTR);
 
-  ~FlowScene();
+  FlowScene(QObject* parent = Q_NULLPTR);
 
-public:
+  ~FlowScene() override;
 
+ public:
   std::shared_ptr<Connection>
   createConnection(PortType connectedPort,
                    Node& node,
-                   PortIndex portIndex);
+                   PortIndex portIndex,
+                   bool isAPreview = false,
+                   void* data = nullptr);
 
   std::shared_ptr<Connection>
   createConnection(Node& nodeIn,
                    PortIndex portIndexIn,
                    Node& nodeOut,
                    PortIndex portIndexOut,
-                   TypeConverter const & converter = TypeConverter{});
+                   TypeConverter const& converter = TypeConverter{},
+                   bool isAPreview = false,
+                   void* data = nullptr);
 
-  std::shared_ptr<Connection> restoreConnection(QJsonObject const &connectionJson);
+  std::shared_ptr<Connection>
+  restoreConnection(QJsonObject const& connectionJson);
 
   void deleteConnection(Connection& connection);
 
-  Node&createNode(std::unique_ptr<NodeDataModel> && dataModel);
+  Node& createNode(std::unique_ptr<NodeDataModel>&& dataModel);
 
-  Node&restoreNode(QJsonObject const& nodeJson);
+  Node& restoreNode(QJsonObject const& nodeJson);
 
   void removeNode(Node& node);
 
-  DataModelRegistry&registry() const;
+  DataModelRegistry& registry() const;
 
   void setRegistry(std::shared_ptr<DataModelRegistry> registry);
 
-  void iterateOverNodes(std::function<void(Node*)> const & visitor);
+  void iterateOverNodes(std::function<void(Node*)> const& visitor);
 
-  void iterateOverNodeData(std::function<void(NodeDataModel*)> const & visitor);
+  void iterateOverNodeData(std::function<void(NodeDataModel*)> const& visitor);
 
-  void iterateOverNodeDataDependentOrder(std::function<void(NodeDataModel*)> const & visitor);
+  void iterateOverNodeDataDependentOrder(std::function<void(NodeDataModel*)> const& visitor);
 
   QPointF getNodePosition(Node const& node) const;
 
@@ -78,53 +78,113 @@ public:
 
   QSizeF getNodeSize(Node const& node) const;
 
-public:
+  // MK : use read only property for the scene
+  void setReadOnly(bool ro);
+
+  bool isReadOnly() const;
 
-  std::unordered_map<QUuid, std::unique_ptr<Node> > const & nodes() const;
+ public:
+  std::unordered_map<QUuid, std::unique_ptr<Node> > const& nodes() const;
 
-  std::unordered_map<QUuid, std::shared_ptr<Connection> > const & connections() const;
+  std::unordered_map<QUuid, std::shared_ptr<Connection> > const& connections() const;
 
   std::vector<Node*> allNodes() const;
 
   std::vector<Node*> selectedNodes() const;
 
-public:
-
+ public:
   void clearScene();
 
+  /// @name File IO
+  ///
+  /// These functions are for saving to and loading from files.
+  ///
+  /// @note These functions will launch a file dialog to retrieve a suitable
+  /// path for the JSON document.
+  ///
+  /// @{
+
+  /// Open a FileDialog to save the scene in a .flow file
   void save() const;
 
+  /// Load a FileDialog to open a scene from a .flow file
   void load();
 
-  QByteArray saveToMemory() const;
+  /// @name Memory IO
+  ///
+  /// These functions are for saving to and loading from memory.
+  ///
+  /// @{
+
+  /// Dump the scene on a JSON QByteArray
+  QByteArray saveToMemory(
+      QJsonDocument::JsonFormat format = QJsonDocument::Indented) const;
 
+  /// Load a scene from a JSON QByteArray
   void loadFromMemory(const QByteArray& data);
 
-Q_SIGNALS:
+  /// @}
+
+  /// @name JSON Object IO
+  ///
+  /// These functions are for saving to and loading from JSON objects.
+  /// This is useful when embedding the nodes and their connections into a
+  /// JSON document that contains other data.
+  ///
+  /// @{
+
+  /// Dump the scene on a JSON Object.
+  QJsonObject saveToObject() const;
+
+  /// Load a scene from a JSON Object
+  void loadFromObject(const QJsonObject& data);
+
+  /// Load a scene from a JSON Object
+  ///
+  /// @note Internally this is just an alias for @ref FlowScene::loadFromObject.
+  /// It is kept for backwards compatibility.
+  void loadFromMemory(const QJsonObject& data);
+
+  /// @}
+
+  /// Save only a subset of the nodes to memory, as well as the connections that
+  /// link two nodes lying within this subset.
+  QByteArray copyNodes(const std::vector<Node*>& nodes) const;
+
+  //! Paste selected nodes to the scene replacing uuids with new ones with a
+  //! certain offset from the original position.
+  void pasteNodes(const QByteArray& data,
+                  const QPointF& pointOffset = QPointF(0, 0));
+
+ Q_SIGNALS:
 
   /**
    * @brief Node has been created but not on the scene yet.
    * @see nodePlaced()
    */
-  void nodeCreated(Node &n);
+  void nodeCreated(Node& n);
 
   /**
    * @brief Node has been added to the scene.
    * @details Connect to this signal if need a correct position of node.
    * @see nodeCreated()
    */
-  void nodePlaced(Node &n);
+  void nodePlaced(Node& n);
 
-  void nodeDeleted(Node &n);
+  void nodeDeleted(Node& n);
 
-  void connectionCreated(Connection const &c);
-  void connectionDeleted(Connection const &c);
+  void connectionCreated(Connection const& c);
+  void connectionDeleted(Connection const& c);
 
   void nodeMoved(Node& n, const QPointF& newLocation);
 
   void nodeDoubleClicked(Node& n);
 
+  void nodeSelected(Node& n);  // MK : new method
+
   void connectionHovered(Connection& c, QPoint screenPos);
+  void connectionSelected(Connection& c);  // MK : new method
+  void connectionDoubleClicked(Connection& c);  // MK : new method
 
   void nodeHovered(Node& n, QPoint screenPos);
 
@@ -134,10 +194,9 @@ Q_SIGNALS:
 
   void nodeContextMenu(Node& n, const QPointF& pos);
 
-private:
-
+ private:
   using SharedConnection = std::shared_ptr<Connection>;
-  using UniqueNode       = std::unique_ptr<Node>;
+  using UniqueNode = std::unique_ptr<Node>;
 
   // DO NOT reorder this member to go after the others.
   // This should outlive all the connections and nodes of
@@ -146,18 +205,18 @@ private:
   std::shared_ptr<DataModelRegistry> _registry;
 
   std::unordered_map<QUuid, SharedConnection> _connections;
-  std::unordered_map<QUuid, UniqueNode>       _nodes;
+  std::unordered_map<QUuid, UniqueNode> _nodes;
+  bool _readOnly;
 
-private Q_SLOTS:
+ private Q_SLOTS:
 
   void setupConnectionSignals(Connection const& c);
 
   void sendConnectionCreatedToNodes(Connection const& c);
   void sendConnectionDeletedToNodes(Connection const& c);
-
 };
 
 Node*
-locateNodeAt(QPointF scenePoint, FlowScene &scene,
-             QTransform const & viewTransform);
-}
+locateNodeAt(QPointF scenePoint, FlowScene& scene,
+             QTransform const& viewTransform);
+}  // namespace QtNodes
diff --git a/include/nodes/internal/FlowView.hpp b/include/nodes/internal/FlowView.hpp
index 473af4d..f85eb9e 100644
--- a/include/nodes/internal/FlowView.hpp
+++ b/include/nodes/internal/FlowView.hpp
@@ -19,43 +19,77 @@ public:
   FlowView(FlowScene *scene, QWidget *parent = Q_NULLPTR);
 
   FlowView(const FlowView&) = delete;
-  FlowView operator=(const FlowView&) = delete;
+  FlowView
+  operator=(const FlowView&) = delete;
 
-  QAction* clearSelectionAction() const;
+  QAction*
+  clearSelectionAction() const;
 
-  QAction* deleteSelectionAction() const;
+  QAction*
+  deleteSelectionAction() const;
 
-  void setScene(FlowScene *scene);
+  void
+  setScene(FlowScene *scene);
+
+  // MK : use a new property fot the scene : 'ReadOnly'
+  void setReadOnly(bool ro);
+
+  bool isReadOnly() const;
+
+  void limitNodeToRect();
 
 public Q_SLOTS:
 
-  void scaleUp();
+  virtual void
+  scaleUp();
 
-  void scaleDown();
+  virtual void
+  scaleDown();
 
-  void deleteSelectedNodes();
+  virtual void
+  deleteSelectedNodes();
 
 protected:
 
-  void contextMenuEvent(QContextMenuEvent *event) override;
+  void
+  contextMenuEvent(QContextMenuEvent *event) override;
 
-  void wheelEvent(QWheelEvent *event) override;
+  void
+  wheelEvent(QWheelEvent *event) override;
 
-  void keyPressEvent(QKeyEvent *event) override;
+  void
+  keyPressEvent(QKeyEvent *event) override;
 
-  void keyReleaseEvent(QKeyEvent *event) override;
+  void
+  keyReleaseEvent(QKeyEvent *event) override;
 
-  void mousePressEvent(QMouseEvent *event) override;
+  void
+  mousePressEvent(QMouseEvent *event) override;
 
-  void mouseMoveEvent(QMouseEvent *event) override;
+  void
+  mouseMoveEvent(QMouseEvent *event) override;
 
-  void drawBackground(QPainter* painter, const QRectF& r) override;
+  void
+  drawBackground(QPainter* painter, const QRectF& r) override;
 
-  void showEvent(QShowEvent *event) override;
+  void
+  showEvent(QShowEvent *event) override;
 
 protected:
 
-  FlowScene * scene();
+  FlowScene *
+  scene();
+
+  /**
+   * MIME type used to copy/paste and drag n drop nodes.
+   * You will likely want to override it with your own type.
+   * This defaults to 'application/x-nodeeditor-nodes'.
+   */
+  virtual QString nodeMimeType() const;
+
+private:
+   void copy();
+   void paste();
 
 private:
 
diff --git a/include/nodes/internal/Node.hpp b/include/nodes/internal/Node.hpp
index cab7d82..6997055 100644
--- a/include/nodes/internal/Node.hpp
+++ b/include/nodes/internal/Node.hpp
@@ -36,6 +36,8 @@ public:
   /// NodeDataModel should be an rvalue and is moved into the Node
   Node(std::unique_ptr<NodeDataModel> && dataModel);
 
+  Node(std::unique_ptr<NodeDataModel> && dataModel, QUuid&& uuid);
+
   virtual
   ~Node();
 
@@ -89,7 +91,12 @@ public Q_SLOTS: // data propagation
 
   /// Propagates incoming data to the underlying model.
   void
-  propagateData(std::shared_ptr<NodeData> nodeData,
+  propagateData(PortIndex inPortIndex) const;
+  
+  /// RM : propagate data, specific node data, and connections
+  void
+  propagateData(const QtNodes::Connection *c,
+                std::shared_ptr<NodeData> nodeData,
                 PortIndex inPortIndex) const;
 
   /// Fetches data from model's OUT #index port
@@ -101,6 +108,32 @@ public Q_SLOTS: // data propagation
   void
   onNodeSizeUpdated();
 
+  /// Add the specified port and recalculate position of the connections
+  void
+  onPortAdded(PortType portType, PortIndex index);
+
+  void
+  onPortMoved(PortType portType, PortIndex oldIndex, PortIndex newIndex);
+
+  void
+  onPortRemoved(PortType portType, PortIndex index);
+
+Q_SIGNALS:
+
+  void
+  connectionRemoved(Connection& connection);
+
+private:
+
+  void
+  updateGraphics() const;
+
+  void
+  insertEntry(PortType portType, PortIndex index);
+
+  void
+  eraseEntry(PortType portType, PortIndex index);
+
 private:
 
   // addressing
diff --git a/include/nodes/internal/NodeData.hpp b/include/nodes/internal/NodeData.hpp
index 5f8c750..566ecc2 100644
--- a/include/nodes/internal/NodeData.hpp
+++ b/include/nodes/internal/NodeData.hpp
@@ -13,6 +13,30 @@ struct NodeDataType
   QString name;
 };
 
+inline
+bool
+operator<(QtNodes::NodeDataType const & d1,
+          QtNodes::NodeDataType const & d2)
+{
+   return d1.id < d2.id;
+}
+
+inline
+bool
+operator==(QtNodes::NodeDataType const & d1,
+           QtNodes::NodeDataType const & d2)
+{
+   return d1.id == d2.id;
+}
+
+inline
+bool
+operator!=(QtNodes::NodeDataType const & d1,
+           QtNodes::NodeDataType const & d2)
+{
+   return !operator==(d1,d2);
+}
+
 /// Class represents data transferred between nodes.
 /// @param type is used for comparing the types
 /// The actual data is stored in subtypes
diff --git a/include/nodes/internal/NodeDataModel.hpp b/include/nodes/internal/NodeDataModel.hpp
index b65b9ec..d9ad8e1 100644
--- a/include/nodes/internal/NodeDataModel.hpp
+++ b/include/nodes/internal/NodeDataModel.hpp
@@ -1,7 +1,7 @@
 #pragma once
 
-
 #include <QtWidgets/QWidget>
+#include <functional>
 
 #include "PortType.hpp"
 #include "NodeData.hpp"
@@ -67,19 +67,33 @@ public:
 public:
 
   virtual
-  unsigned int nPorts(PortType portType) const = 0;
+  unsigned int
+  nPorts(PortType portType) const = 0;
+
+  /// Return if ports are dynamics
+  virtual
+  bool
+  hasDynamicPorts(PortType) const { return false; }
 
   virtual
-  NodeDataType dataType(PortType portType, PortIndex portIndex) const = 0;
+  NodeDataType
+  dataType(PortType portType, PortIndex portIndex) const = 0;
 
 public:
 
   enum class ConnectionPolicy
   {
     One,
-    Many,
+    Many
   };
 
+  // MK : InData management
+  using InDataValidator = std::function<bool (const NodeDataModel* model, std::shared_ptr<NodeData> nodeData, PortIndex port)>;
+  using InDataSetter = std::function<void (NodeDataModel* model, const QtNodes::Connection* c, std::shared_ptr<NodeData> nodeData, PortIndex port)>;
+
+  ConnectionPolicy
+  portConnectionPolicy(PortType portType, PortIndex portIndex) const;
+
   virtual
   ConnectionPolicy
   portOutConnectionPolicy(PortIndex) const
@@ -87,23 +101,64 @@ public:
     return ConnectionPolicy::Many;
   }
 
+  virtual
+  ConnectionPolicy
+  portInConnectionPolicy(PortIndex) const
+  {
+    return ConnectionPolicy::One;
+  }
+
   NodeStyle const&
   nodeStyle() const;
 
   void
   setNodeStyle(NodeStyle const& style);
 
+  // MK : InData management
+  void setInDataValidator(InDataValidator validator) { _inDataValidator = validator; }
+
+  void setInDataSetter(InDataSetter setter) { _inDataSetter = setter; }
+
 public:
 
+  virtual
+  bool
+  acceptInData(std::shared_ptr<NodeData> nodeData,
+               PortIndex port) const
+  {
+      if(_inDataValidator != nullptr)
+          return _inDataValidator(this, nodeData, port);
+
+      return true;
+  }
+
   /// Triggers the algorithm
   virtual
   void
   setInData(std::shared_ptr<NodeData> nodeData,
             PortIndex port) = 0;
 
+  virtual
+  void
+  setInData(std::vector<std::shared_ptr<NodeData> > nodeData,
+            PortIndex port);
+  
+  void
+  setInData(const QtNodes::Connection* c,
+            std::shared_ptr<NodeData> nodeData,
+            PortIndex port)
+  {
+      if(_inDataSetter != nullptr)
+          _inDataSetter(this, c, nodeData, port);
+  }
+
   virtual
   std::shared_ptr<NodeData>
-  outData(PortIndex port) = 0;
+  inData(PortIndex port) const = 0;
+
+  virtual
+  std::shared_ptr<NodeData>
+  outData(PortIndex port) const = 0;
 
   virtual
   QWidget *
@@ -122,29 +177,22 @@ public:
   validationMessage() const { return QString(""); }
 
   virtual
-  NodePainterDelegate* painterDelegate() const { return nullptr; }
+  NodePainterDelegate*
+  painterDelegate() const { return nullptr; }
 
 public Q_SLOTS:
 
   virtual void
-  inputConnectionCreated(Connection const&)
-  {
-  }
+  inputConnectionCreated(Connection const&) {}
 
   virtual void
-  inputConnectionDeleted(Connection const&)
-  {
-  }
+  inputConnectionDeleted(Connection const&) {}
 
   virtual void
-  outputConnectionCreated(Connection const&)
-  {
-  }
+  outputConnectionCreated(Connection const&) {}
 
   virtual void
-  outputConnectionDeleted(Connection const&)
-  {
-  }
+  outputConnectionDeleted(Connection const&) {}
 
 Q_SIGNALS:
 
@@ -160,10 +208,22 @@ Q_SIGNALS:
   void
   computingFinished();
 
-  void embeddedWidgetSizeUpdated();
+  void
+  embeddedWidgetSizeUpdated();
+
+  void
+  portAdded(PortType type, PortIndex index);
+
+  void
+  portMoved(PortType type, PortIndex oldIndex, PortIndex newIndex);
+
+  void
+  portRemoved(PortType type, PortIndex index);
 
 private:
 
   NodeStyle _nodeStyle;
+  InDataValidator _inDataValidator;
+  InDataSetter _inDataSetter;
 };
 }
diff --git a/include/nodes/internal/NodeGeometry.hpp b/include/nodes/internal/NodeGeometry.hpp
index 0a8ea4e..18f4601 100644
--- a/include/nodes/internal/NodeGeometry.hpp
+++ b/include/nodes/internal/NodeGeometry.hpp
@@ -149,6 +149,7 @@ private:
 
   bool _hovered;
 
+  // MK : used for Node size calculation depending on in/out number of port
   unsigned int _nSources;
   unsigned int _nSinks;
 
diff --git a/include/nodes/internal/NodeGraphicsObject.hpp b/include/nodes/internal/NodeGraphicsObject.hpp
index fe87c6c..48bdcb3 100644
--- a/include/nodes/internal/NodeGraphicsObject.hpp
+++ b/include/nodes/internal/NodeGraphicsObject.hpp
@@ -7,6 +7,7 @@
 
 #include "NodeGeometry.hpp"
 #include "NodeState.hpp"
+#include "Export.hpp"
 
 class QGraphicsProxyWidget;
 
@@ -18,7 +19,7 @@ class FlowItemEntry;
 
 /// Class reacts on GUI events, mouse clicks and
 /// forwards painting operation.
-class NodeGraphicsObject : public QGraphicsObject
+class NODE_EDITOR_PUBLIC NodeGraphicsObject : public QGraphicsObject
 {
   Q_OBJECT
 
@@ -54,6 +55,13 @@ public:
   void
   lock(bool locked);
 
+  // RM : Add the notion of 'reference' node
+  void
+  setRef(bool ref) { _ref = ref; }
+
+  bool
+  ref() { return _ref; }
+
 protected:
   void
   paint(QPainter*                       painter,
@@ -97,6 +105,9 @@ private:
 
   Node& _node;
 
+  // RM : Add the notion of 'reference' node
+  bool _ref;
+
   bool _locked;
 
   // either nullptr or owned by parent QGraphicsItem
diff --git a/include/nodes/internal/NodeState.hpp b/include/nodes/internal/NodeState.hpp
index 966bd46..dc6d1ec 100644
--- a/include/nodes/internal/NodeState.hpp
+++ b/include/nodes/internal/NodeState.hpp
@@ -46,7 +46,8 @@ public:
   getEntries(PortType);
 
   ConnectionPtrSet
-  connections(PortType portType, PortIndex portIndex) const;
+  connections(PortType portType,
+              PortIndex portIndex) const;
 
   void
   setConnection(PortType portType,
@@ -70,7 +71,6 @@ public:
   void
   setReaction(ReactToConnectionState reaction,
               PortType reactingPortType = PortType::None,
-
               NodeDataType reactingDataType =
                 NodeDataType());
 
diff --git a/resources/DefaultStyle.json b/resources/DefaultStyle.json
index 8375b4a..52d1079 100644
--- a/resources/DefaultStyle.json
+++ b/resources/DefaultStyle.json
@@ -1,16 +1,16 @@
 {
   "FlowViewStyle": {
     "BackgroundColor": [53, 53, 53],
-    "FineGridColor": [60, 60, 60],
-    "CoarseGridColor": [25, 25, 25]
+    "FineGridColor": [53, 53, 53],
+    "CoarseGridColor": [53, 53, 53]
   },
   "NodeStyle": {
     "NormalBoundaryColor": [255, 255, 255],
     "SelectedBoundaryColor": [255, 165, 0],
-    "GradientColor0": "gray",
+    "GradientColor0": [80, 80, 80],
     "GradientColor1": [80, 80, 80],
-    "GradientColor2": [64, 64, 64],
-    "GradientColor3": [58, 58, 58],
+    "GradientColor2": [80, 80, 80],
+    "GradientColor3": [80, 80, 80],
     "ShadowColor": [20, 20, 20],
     "FontColor" : "white",
     "FontColorFaded" : "gray",
@@ -24,19 +24,23 @@
 
     "ConnectionPointDiameter": 8.0,
 
-    "Opacity": 0.8
+    "Opacity": 1.0
   },
   "ConnectionStyle": {
-    "ConstructionColor": "gray",
+    "ConstructionColor": [127, 127, 127],
     "NormalColor": "darkcyan",
     "SelectedColor": [100, 100, 100],
     "SelectedHaloColor": "orange",
     "HoveredColor": "lightcyan",
 
+    "GroupColor": [204, 227, 239],
+    "ItemColor": [244, 166, 131],
+    "AttributeColor": [64, 143, 193],
+
     "LineWidth": 3.0,
-    "ConstructionLineWidth": 2.0,
+    "ConstructionLineWidth": 1.0,
     "PointDiameter": 10.0,
 
-    "UseDataDefinedColors": false
+    "UseDataDefinedColors": true
   }
 }
diff --git a/resources/nodeeditor.qrc b/resources/nodeeditor.qrc
new file mode 100644
index 0000000..14ef431
--- /dev/null
+++ b/resources/nodeeditor.qrc
@@ -0,0 +1,6 @@
+<RCC version="1.0">
+    <qresource>
+        <file>DefaultStyle.json</file>
+        <file>convert.png</file>
+    </qresource>
+</RCC>
diff --git a/src/Connection.cpp b/src/Connection.cpp
index 2375b84..89b8794 100644
--- a/src/Connection.cpp
+++ b/src/Connection.cpp
@@ -32,11 +32,13 @@ using QtNodes::TypeConverter;
 Connection::
 Connection(PortType portType,
            Node& node,
-           PortIndex portIndex)
+           PortIndex portIndex,
+           void* data)
   : _uid(QUuid::createUuid())
   , _outPortIndex(INVALID)
   , _inPortIndex(INVALID)
-  , _connectionState()
+  , _connectionState(),
+    mData(data)
 {
   setNodeToPort(node, portType, portIndex);
 
@@ -49,14 +51,16 @@ Connection(Node& nodeIn,
            PortIndex portIndexIn,
            Node& nodeOut,
            PortIndex portIndexOut,
-           TypeConverter typeConverter)
+           TypeConverter typeConverter,
+           void* data)
   : _uid(QUuid::createUuid())
   , _outNode(&nodeOut)
   , _inNode(&nodeIn)
   , _outPortIndex(portIndexOut)
   , _inPortIndex(portIndexIn)
   , _connectionState()
-  , _converter(std::move(typeConverter))
+  , _converter(std::move(typeConverter)),
+    mData(data)
 {
   setNodeToPort(nodeIn, PortType::In, portIndexIn);
   setNodeToPort(nodeOut, PortType::Out, portIndexOut);
@@ -67,11 +71,10 @@ Connection::
 ~Connection()
 {
   if (complete())
-  {
-    connectionMadeIncomplete(*this);
-  }
+      connectionMadeIncomplete(*this);
 
-  propagateEmptyData();
+  if(!connectionState().isAPreview())
+      propagateEmptyData();
 
   if (_inNode)
   {
@@ -95,9 +98,11 @@ save() const
   {
     connectionJson["in_id"] = _inNode->id().toString();
     connectionJson["in_index"] = _inPortIndex;
+    connectionJson["in_type"] = _inNode->nodeDataModel()->dataType(PortType::In, _inPortIndex).id;
 
     connectionJson["out_id"] = _outNode->id().toString();
     connectionJson["out_index"] = _outPortIndex;
+    connectionJson["out_type"] = _outNode->nodeDataModel()->dataType(PortType::Out, _outPortIndex).id;
 
     if (_converter)
     {
@@ -271,6 +276,17 @@ removeFromNodes() const
     _outNode->nodeState().eraseConnection(PortType::Out, _outPortIndex, id());
 }
 
+void*
+Connection::
+data() const
+{
+    return mData;
+}
+
+void Connection::setData(void* newData)
+{
+    mData = newData;
+}
 
 ConnectionGraphicsObject&
 Connection::
@@ -380,14 +396,18 @@ dataType(PortType portType) const
 {
   if (_inNode && _outNode)
   {
-    auto const & model = (portType == PortType::In) ?
-                        _inNode->nodeDataModel() :
-                        _outNode->nodeDataModel();
+    auto model = (portType == PortType::In) ?
+                  _inNode->nodeDataModel() :
+                  _outNode->nodeDataModel();
     PortIndex index = (portType == PortType::In) ? 
                       _inPortIndex :
                       _outPortIndex;
 
-    return model->dataType(portType, index);
+    if(model){
+      return model->dataType(portType, index);
+    }
+
+    return NodeDataType{};
   }
   else 
   {
@@ -416,6 +436,10 @@ dataType(PortType portType) const
   Q_UNREACHABLE();
 }
 
+QtNodes::TypeConverter& Connection::typeConverter()
+{
+    return _converter;
+}
 
 void
 Connection::
@@ -425,6 +449,19 @@ setTypeConverter(TypeConverter converter)
 }
 
 
+void
+Connection::
+propagateData() const
+{
+   if (_inNode && _inNode->nodeDataModel())
+  {
+     if (_inPortIndex < static_cast<int>(_inNode->nodeDataModel()->nPorts(PortType::In)))
+    {
+      _inNode->propagateData(_inPortIndex);
+    }
+  }
+}
+
 void
 Connection::
 propagateData(std::shared_ptr<NodeData> nodeData) const
@@ -436,7 +473,7 @@ propagateData(std::shared_ptr<NodeData> nodeData) const
       nodeData = _converter(nodeData);
     }
 
-    _inNode->propagateData(nodeData, _inPortIndex);
+    _inNode->propagateData(this, nodeData, _inPortIndex);
   }
 }
 
@@ -445,7 +482,5 @@ void
 Connection::
 propagateEmptyData() const
 {
-  std::shared_ptr<NodeData> emptyData;
-
-  propagateData(emptyData);
+  propagateData();
 }
diff --git a/src/ConnectionGraphicsObject.cpp b/src/ConnectionGraphicsObject.cpp
index 8fff264..8b00d49 100644
--- a/src/ConnectionGraphicsObject.cpp
+++ b/src/ConnectionGraphicsObject.cpp
@@ -100,7 +100,7 @@ void
 ConnectionGraphicsObject::
 move()
 {
-  for(PortType portType: { PortType::In, PortType::Out } )
+  for (PortType portType: { PortType::In, PortType::Out })
   {
     if (auto node = _connection.getNode(portType))
     {
@@ -124,10 +124,12 @@ move()
       _connection.getConnectionGraphicsObject().update();
     }
   }
-
 }
 
-void ConnectionGraphicsObject::lock(bool locked)
+
+void
+ConnectionGraphicsObject::
+lock(bool locked)
 {
   setFlag(QGraphicsItem::ItemIsMovable, !locked);
   setFlag(QGraphicsItem::ItemIsFocusable, !locked);
@@ -143,8 +145,7 @@ paint(QPainter* painter,
 {
   painter->setClipRect(option->exposedRect);
 
-  ConnectionPainter::paint(painter,
-                           _connection);
+  ConnectionPainter::paint(painter, _connection);
 }
 
 
@@ -153,7 +154,6 @@ ConnectionGraphicsObject::
 mousePressEvent(QGraphicsSceneMouseEvent* event)
 {
   QGraphicsItem::mousePressEvent(event);
-  //event->ignore();
 }
 
 
@@ -161,20 +161,25 @@ void
 ConnectionGraphicsObject::
 mouseMoveEvent(QGraphicsSceneMouseEvent* event)
 {
-  prepareGeometryChange();
+  Q_UNUSED(event);
+  return ;
+
+  // We don't want to move manually the connexions anymore
+  /*prepareGeometryChange();
 
   auto view = static_cast<QGraphicsView*>(event->widget());
   auto node = locateNodeAt(event->scenePos(),
                            _scene,
                            view->transform());
 
-  auto &state = _connection.connectionState();
+  auto & connectionState = _connection.connectionState();
 
-  state.interactWithNode(node);
+  connectionState.interactWithNode(node);
   if (node)
   {
-    node->reactToPossibleConnection(state.requiredPort(),
-                                    _connection.dataType(oppositePort(state.requiredPort())),
+    auto oppPort = oppositePort(connectionState.requiredPort());
+    node->reactToPossibleConnection(connectionState.requiredPort(),
+                                    _connection.dataType(oppPort),
                                     event->scenePos());
   }
 
@@ -184,6 +189,7 @@ mouseMoveEvent(QGraphicsSceneMouseEvent* event)
 
   auto requiredPort = _connection.requiredPort();
 
+  // This moves the loose end exactly to the mouse position
   if (requiredPort != PortType::None)
   {
     _connection.connectionGeometry().moveEndPoint(requiredPort, offset);
@@ -193,7 +199,7 @@ mouseMoveEvent(QGraphicsSceneMouseEvent* event)
 
   update();
 
-  event->accept();
+  event->accept();*/
 }
 
 
@@ -201,6 +207,9 @@ void
 ConnectionGraphicsObject::
 mouseReleaseEvent(QGraphicsSceneMouseEvent* event)
 {
+  // MK : to enable multi selection !
+  QGraphicsItem::mouseReleaseEvent(event);
+
   ungrabMouse();
   event->accept();
 
@@ -218,6 +227,11 @@ mouseReleaseEvent(QGraphicsSceneMouseEvent* event)
   {
     _scene.deleteConnection(_connection);
   }
+  // MK : to enable multi selection !
+  else if(isSelected())
+  {
+      _scene.connectionSelected(connection());
+  }
 }
 
 
@@ -244,6 +258,11 @@ hoverLeaveEvent(QGraphicsSceneHoverEvent* event)
   event->accept();
 }
 
+void ConnectionGraphicsObject::mouseDoubleClickEvent(QGraphicsSceneMouseEvent*)
+{
+    _scene.connectionDoubleClicked(connection());
+}
+
 
 void
 ConnectionGraphicsObject::
diff --git a/src/ConnectionPainter.cpp b/src/ConnectionPainter.cpp
index 11d31af..0394711 100644
--- a/src/ConnectionPainter.cpp
+++ b/src/ConnectionPainter.cpp
@@ -107,7 +107,8 @@ drawSketchLine(QPainter * painter,
   ConnectionState const& state =
     connection.connectionState();
 
-  if (state.requiresPort())
+  // MK : use preview state
+  if (state.requiresPort() || state.isAPreview())
   {
     auto const & connectionStyle =
       QtNodes::StyleCollection::connectionStyle();
@@ -115,7 +116,8 @@ drawSketchLine(QPainter * painter,
     QPen p;
     p.setWidth(connectionStyle.constructionLineWidth());
     p.setColor(connectionStyle.constructionColor());
-    p.setStyle(Qt::DashLine);
+    // RM : remove dashed line for preview connections
+    //p.setStyle(Qt::DashLine);
 
     painter->setPen(p);
     painter->setBrush(Qt::NoBrush);
@@ -178,7 +180,8 @@ drawNormalLine(QPainter * painter,
   ConnectionState const& state =
     connection.connectionState();
 
-  if (state.requiresPort())
+  // MK : use preview state
+  if (state.requiresPort() || state.isAPreview())
     return;
 
   // colors
@@ -252,7 +255,8 @@ drawNormalLine(QPainter * painter,
                         cubic.pointAtPercent(ratio));
     }
 
-    {
+    // MK : don't use the icon
+    /*{
       QIcon icon(":convert.png");
 
       QPixmap pixmap = icon.pixmap(QSize(22, 22));
@@ -260,7 +264,7 @@ drawNormalLine(QPainter * painter,
                                                               pixmap.height()/2),
                           pixmap);
 
-    }
+    }*/
   }
   else
   {
diff --git a/src/ConnectionStyle.cpp b/src/ConnectionStyle.cpp
index 2451164..0ee80d4 100644
--- a/src/ConnectionStyle.cpp
+++ b/src/ConnectionStyle.cpp
@@ -9,12 +9,13 @@
 #include <QtCore/QJsonArray>
 
 #include <QDebug>
+#include <QRandomGenerator>
 
 #include "StyleCollection.hpp"
 
 using QtNodes::ConnectionStyle;
 
-inline void initResources() { Q_INIT_RESOURCE(resources); }
+inline void initResources() { Q_INIT_RESOURCE(nodeeditor); }
 
 ConnectionStyle::
 ConnectionStyle()
@@ -134,6 +135,10 @@ loadJsonFromByteArray(QByteArray const &byteArray)
   CONNECTION_STYLE_READ_COLOR(obj, SelectedHaloColor);
   CONNECTION_STYLE_READ_COLOR(obj, HoveredColor);
 
+  CONNECTION_STYLE_READ_COLOR(obj, GroupColor);
+  CONNECTION_STYLE_READ_COLOR(obj, ItemColor);
+  CONNECTION_STYLE_READ_COLOR(obj, AttributeColor);
+
   CONNECTION_STYLE_READ_FLOAT(obj, LineWidth);
   CONNECTION_STYLE_READ_FLOAT(obj, ConstructionLineWidth);
   CONNECTION_STYLE_READ_FLOAT(obj, PointDiameter);
@@ -162,18 +167,34 @@ QColor
 ConnectionStyle::
 normalColor(QString typeId) const
 {
-  std::size_t hash = qHash(typeId);
+  if(typeId == "GROUP")
+      return GroupColor;
+      //return QColor(QRgb(0xba220f)); // Brick Red
+
+  if(typeId == "ITEM")
+      return ItemColor;
+      //return QColor(QRgb(0x0f52ba)); // Saphir Blue
+
+  if(typeId == "ATTRIBUTE")
+      return AttributeColor;
+      //return QColor(QRgb(0x228b22)); // Forest Green
+
+  // Should never finish here
+  return QColor(QRgb(0x808080)); // Middle Gray
+
+  /*std::size_t hash = qHash(typeId);
 
   std::size_t const hue_range = 0xFF;
 
-  qsrand(hash);
-  std::size_t hue = qrand() % hue_range;
+  QRandomGenerator random{static_cast<quint32>(hash)};
+  std::size_t hue = random.generate() % hue_range;
 
-  std::size_t sat = 120 + hash % 129;
+  std::size_t sat = 200; // RM : For sharper colors
+  //std::size_t sat = 120 + hash % 129;
 
-  return QColor::fromHsl(hue,
-                         sat,
-                         160);
+  return QColor::fromHsl(int(hue),
+                         int(sat),
+                         160);*/
 }
 
 
@@ -200,6 +221,26 @@ hoveredColor() const
   return HoveredColor;
 }
 
+QColor
+ConnectionStyle::
+groupColor() const
+{
+  return GroupColor;
+}
+
+QColor
+ConnectionStyle::
+itemColor() const
+{
+  return ItemColor;
+}
+
+QColor
+ConnectionStyle::
+attributeColor() const
+{
+  return AttributeColor;
+}
 
 float
 ConnectionStyle::
diff --git a/src/FlowScene.cpp b/src/FlowScene.cpp
index f332f14..f2c75e1 100644
--- a/src/FlowScene.cpp
+++ b/src/FlowScene.cpp
@@ -10,7 +10,6 @@
 #include <QtCore/QDataStream>
 #include <QtCore/QFile>
 
-#include <QtCore/QJsonDocument>
 #include <QtCore/QJsonObject>
 #include <QtCore/QJsonArray>
 #include <QtCore/QtGlobal>
@@ -43,6 +42,7 @@ FlowScene(std::shared_ptr<DataModelRegistry> registry,
           QObject * parent)
   : QGraphicsScene(parent)
   , _registry(std::move(registry))
+  , _readOnly(false)
 {
   setItemIndexMethod(QGraphicsScene::NoIndex);
 
@@ -52,6 +52,7 @@ FlowScene(std::shared_ptr<DataModelRegistry> registry,
   connect(this, &FlowScene::connectionDeleted, this, &FlowScene::sendConnectionDeletedToNodes);
 }
 
+
 FlowScene::
 FlowScene(QObject * parent)
   : FlowScene(std::make_shared<DataModelRegistry>(),
@@ -72,9 +73,12 @@ std::shared_ptr<Connection>
 FlowScene::
 createConnection(PortType connectedPort,
                  Node& node,
-                 PortIndex portIndex)
+                 PortIndex portIndex,
+                 bool isAPreview,
+                 void* data)
 {
-  auto connection = std::make_shared<Connection>(connectedPort, node, portIndex);
+  auto connection = std::make_shared<Connection>(connectedPort, node, portIndex, data);
+  connection->connectionState().setIsAPreview(isAPreview);
 
   auto cgo = detail::make_unique<ConnectionGraphicsObject>(*this, *connection);
 
@@ -103,14 +107,19 @@ createConnection(Node& nodeIn,
                  PortIndex portIndexIn,
                  Node& nodeOut,
                  PortIndex portIndexOut,
-                 TypeConverter const &converter)
+                 TypeConverter const &converter,
+                 bool isAPreview,
+                 void* data)
 {
   auto connection =
     std::make_shared<Connection>(nodeIn,
                                  portIndexIn,
                                  nodeOut,
                                  portIndexOut,
-                                 converter);
+                                 converter,
+                                 data);
+
+  connection->connectionState().setIsAPreview(isAPreview);
 
   auto cgo = detail::make_unique<ConnectionGraphicsObject>(*this, *connection);
 
@@ -121,7 +130,13 @@ createConnection(Node& nodeIn,
   connection->setGraphicsObject(std::move(cgo));
 
   // trigger data propagation
-  nodeOut.onDataUpdated(portIndexOut);
+  //nodeOut.onDataUpdated(portIndexOut);
+  // MK : replaced by :
+  if(!isAPreview)
+  {
+      auto nodeData = nodeOut.nodeDataModel()->outData(portIndexOut);
+      connection->propagateData(nodeData);
+  }
 
   _connections[connection->id()] = connection;
 
@@ -158,7 +173,7 @@ restoreConnection(QJsonObject const &connectionJson)
       NodeDataType outType { converterJson["out"].toObject()["id"].toString(),
                              converterJson["out"].toObject()["name"].toString() };
 
-      auto converter  =
+      auto converter =
         registry().getTypeConverter(outType, inType);
 
       if (converter)
@@ -168,10 +183,16 @@ restoreConnection(QJsonObject const &connectionJson)
     return TypeConverter{};
   };
 
-  std::shared_ptr<Connection> connection =
-    createConnection(*nodeIn, portIndexIn,
-                     *nodeOut, portIndexOut,
-                     getConverter());
+  std::shared_ptr<Connection> connection;
+  int const inSize = static_cast<int>(nodeIn->nodeState().getEntries(PortType::In).size());
+  int const outSize = static_cast<int>(nodeOut->nodeState().getEntries(PortType::Out).size());
+  if ((portIndexIn < inSize) && (portIndexOut < outSize))
+  {
+     connection =
+        createConnection(*nodeIn, portIndexIn,
+                         *nodeOut, portIndexOut,
+                         getConverter());
+  }
 
   // Note: the connectionCreated(...) signal has already been sent
   // by createConnection(...)
@@ -183,13 +204,10 @@ restoreConnection(QJsonObject const &connectionJson)
 void
 FlowScene::
 deleteConnection(Connection& connection)
-{
-  auto it = _connections.find(connection.id());
-  if (it != _connections.end())
-  {
-    connection.removeFromNodes();
-    _connections.erase(it);
-  }
+{ 
+  connection.removeFromNodes();
+  Q_EMIT connectionDeleted(connection);
+  _connections.erase(connection.id());
 }
 
 
@@ -205,7 +223,9 @@ createNode(std::unique_ptr<NodeDataModel> && dataModel)
   auto nodePtr = node.get();
   _nodes[node->id()] = std::move(node);
 
-  nodeCreated(*nodePtr);
+  connect(nodePtr, &Node::connectionRemoved, this, &FlowScene::deleteConnection);
+
+  Q_EMIT nodeCreated(*nodePtr);
   return *nodePtr;
 }
 
@@ -222,17 +242,27 @@ restoreNode(QJsonObject const& nodeJson)
     throw std::logic_error(std::string("No registered model with name ") +
                            modelName.toLocal8Bit().data());
 
-  auto node = detail::make_unique<Node>(std::move(dataModel));
+  // restore data model before the node, to be able to restore dynamic ports.
+  dataModel->restore(nodeJson["model"].toObject());
+
+  // create a node with uuid taken from json
+  auto node = detail::make_unique<Node>(std::move(dataModel), QUuid(nodeJson["id"].toString()));
+
+  // create node graphics object
   auto ngo  = detail::make_unique<NodeGraphicsObject>(*this, *node);
-  node->setGraphicsObject(std::move(ngo));
+  QJsonObject positionJson = nodeJson["position"].toObject();
+  QPointF point(positionJson["x"].toDouble(), positionJson["y"].toDouble());
+  ngo->setPos(point);
 
-  node->restore(nodeJson);
+  node->setGraphicsObject(std::move(ngo));
 
   auto nodePtr = node.get();
   _nodes[node->id()] = std::move(node);
 
-  nodePlaced(*nodePtr);
-  nodeCreated(*nodePtr);
+  connect(nodePtr, &Node::connectionRemoved, this, &FlowScene::deleteConnection);
+
+  Q_EMIT nodePlaced(*nodePtr);
+  Q_EMIT nodeCreated(*nodePtr);
   return *nodePtr;
 }
 
@@ -241,10 +271,9 @@ void
 FlowScene::
 removeNode(Node& node)
 {
-  // call signal
-  nodeDeleted(node);
+  Q_EMIT nodeDeleted(node);
 
-  for(auto portType: {PortType::In,PortType::Out})
+  for (auto portType: {PortType::In, PortType::Out})
   {
     auto nodeState = node.nodeState();
     auto const & nodeEntries = nodeState.getEntries(portType);
@@ -256,6 +285,8 @@ removeNode(Node& node)
     }
   }
 
+  disconnect(&node, &Node::connectionRemoved, this, &FlowScene::deleteConnection);
+
   _nodes.erase(node.id());
 }
 
@@ -338,7 +369,7 @@ iterateOverNodeDataDependentOrder(std::function<void(NodeDataModel*)> const & vi
     {
       for (size_t i = 0; i < model.nPorts(PortType::In); ++i)
       {
-        auto connections = node.nodeState().connections(PortType::In, i);
+        auto connections = node.nodeState().connections(PortType::In, static_cast<PortIndex>(i));
 
         for (auto& conn : connections)
         {
@@ -397,6 +428,15 @@ getNodeSize(const Node& node) const
   return QSizeF(node.nodeGeometry().width(), node.nodeGeometry().height());
 }
 
+void FlowScene::setReadOnly(bool ro)
+{
+    _readOnly = ro;
+}
+
+bool FlowScene::isReadOnly() const
+{
+    return _readOnly;
+}
 
 std::unordered_map<QUuid, std::unique_ptr<Node> > const &
 FlowScene::
@@ -458,7 +498,7 @@ void
 FlowScene::
 clearScene()
 {
-  //Manual node cleanup. Simply clearing the holding datastructures doesn't work, the code crashes when
+  // Manual node cleanup. Simply clearing the holding datastructures doesn't work, the code crashes when
   // there are both nodes and connections in the scene. (The data propagation internal logic tries to propagate
   // data through already freed connections.)
   while (_connections.size() > 0)
@@ -512,20 +552,30 @@ load()
 
   QFile file(fileName);
 
-  if (!file.open(QIODevice::ReadOnly))
-    return;
-
-  clearScene();
-
-  QByteArray wholeFile = file.readAll();
+  if (file.open(QIODevice::ReadOnly)){
+     clearScene();
+     loadFromMemory(file.readAll());
+  }
+}
 
-  loadFromMemory(wholeFile);
+QByteArray
+FlowScene::
+saveToMemory(QJsonDocument::JsonFormat format) const
+{
+  return QJsonDocument(saveToObject()).toJson(format);
 }
 
+void
+FlowScene::
+loadFromMemory(const QByteArray& data)
+{
+  const QJsonObject jsonDocument = QJsonDocument::fromJson(data).object();
+  loadFromMemory(jsonDocument);
+}
 
-QByteArray
+QJsonObject
 FlowScene::
-saveToMemory() const
+saveToObject() const
 {
   QJsonObject sceneJson;
 
@@ -553,33 +603,148 @@ saveToMemory() const
 
   sceneJson["connections"] = connectionJsonArray;
 
-  QJsonDocument document(sceneJson);
+  return sceneJson;
+}
+
+void
+FlowScene::
+loadFromObject(const QJsonObject& data)
+{
+   QJsonArray nodesJsonArray = data["nodes"].toArray();
+
+   for (QJsonValueRef node : nodesJsonArray)
+   {
+      restoreNode(node.toObject());
+   }
+
+   QJsonArray connectionJsonArray = data["connections"].toArray();
 
-  return document.toJson();
+   for (QJsonValueRef connection : connectionJsonArray)
+   {
+      restoreConnection(connection.toObject());
+   }
 }
 
+void FlowScene::loadFromMemory(const QJsonObject& data)
+{
+  loadFromObject(data);
+}
 
-void
+QByteArray
 FlowScene::
-loadFromMemory(const QByteArray& data)
+copyNodes(const std::vector<QtNodes::Node*>& nodes) const
 {
-  QJsonObject const jsonDocument = QJsonDocument::fromJson(data).object();
+   QJsonObject sceneJson;
+   QSet<QUuid> nodeIds;
+   QJsonArray nodesJsonArray;
+
+   // center of gravity
+   std::vector<int> cogX;
+   std::vector<int> cogY;
+
+   for (auto const & n : nodes)
+   {
+      auto nodeJson = n->save();
+      nodesJsonArray.append(nodeJson);
+      nodeIds.insert(n->id());
+
+      auto nodePosition = nodeJson = nodeJson["position"].toObject();
+      cogX.emplace_back(nodePosition["x"].toDouble());
+      cogY.emplace_back(nodePosition["y"].toDouble());
+   }
+
+   sceneJson["nodes"] = nodesJsonArray;
+
+   QJsonArray connectionJsonArray;
+   for (auto const & pair : connections())
+   {
+      auto const &connection = pair.second;
+
+      auto inNodeId = connection->getNode(PortType::In)->id();
+      auto outNodeId = connection->getNode(PortType::Out)->id();
+      if (nodeIds.contains(inNodeId) && nodeIds.contains(outNodeId))
+      {
+         QJsonObject connectionJson = connection->save();
+         if (!connectionJson.isEmpty())
+            connectionJsonArray.append(connectionJson);
+      }
+   }
 
-  QJsonArray nodesJsonArray = jsonDocument["nodes"].toArray();
+   sceneJson["connections"] = connectionJsonArray;
 
-  for (QJsonValueRef node : nodesJsonArray)
-  {
-    restoreNode(node.toObject());
-  }
+   // save center of gravity too
+   if(cogX.size() > 0){
+      QJsonObject jsonCog;
+      jsonCog["x"] = std::accumulate(cogX.begin(), cogX.end(), 0) / static_cast<double>(cogX.size());
+      jsonCog["y"] = std::accumulate(cogY.begin(), cogY.end(), 0) / static_cast<double>(cogY.size());
+      sceneJson["cog"] = jsonCog;
+   }
 
-  QJsonArray connectionJsonArray = jsonDocument["connections"].toArray();
+   QJsonDocument document(sceneJson);
 
-  for (QJsonValueRef connection : connectionJsonArray)
-  {
-    restoreConnection(connection.toObject());
-  }
+   return document.toJson();
 }
 
+void FlowScene::pasteNodes(const QByteArray& data, const QPointF& pointOffset)
+{
+   QMap<QUuid,QUuid> newIdsMap;
+   QJsonObject jsonDocument = QJsonDocument::fromJson(data).object();
+
+   // if exists a center of gravity, take it
+   auto jsonCog = jsonDocument["cog"].toObject();
+   double offsetX = pointOffset.x() - jsonCog["x"].toDouble();
+   double offsetY = pointOffset.y() - jsonCog["y"].toDouble();
+
+   QJsonArray nodesJsonArray = jsonDocument["nodes"].toArray();
+   for (auto node : nodesJsonArray)
+   {
+      auto nodeJson = node.toObject();
+
+      QString oldId = nodeJson["id"].toString();
+      if (!newIdsMap.contains(oldId))
+         newIdsMap[oldId] = QUuid::createUuid();
+
+      nodeJson["id"] = newIdsMap[oldId].toString();
+
+      // update position of the copy of the nodes
+      auto nodePosition = nodeJson["position"].toObject();
+      nodePosition["x"] = nodePosition["x"].toDouble() + offsetX;
+      nodePosition["y"] = nodePosition["y"].toDouble() + offsetY;
+      nodeJson["position"] = nodePosition;
+
+      node = nodeJson;
+   }
+   jsonDocument["nodes"] = nodesJsonArray;
+
+   QJsonArray connectionJsonArray = jsonDocument["connections"].toArray();
+   for (QJsonValueRef connection : connectionJsonArray)
+   {
+      auto connectionJson = connection.toObject();
+
+      QString oldId = connectionJson["in_id"].toString();
+      if (newIdsMap.contains(oldId))
+         connectionJson["in_id"] = newIdsMap[oldId].toString();
+
+      oldId = connectionJson["out_id"].toString();
+      if (newIdsMap.contains(oldId))
+         connectionJson["out_id"] = newIdsMap[oldId].toString();
+
+      connection = connectionJson;
+   }
+   jsonDocument["connections"] = connectionJsonArray;
+
+   try {
+      loadFromMemory(QJsonDocument(jsonDocument).toJson());
+   } catch (const std::logic_error& e) {
+      // prevent pasting if receving scene has not registered the source node
+      // it can be happens copying and pasting between different scenes
+
+      Q_UNUSED(e);
+
+      qDebug() << "cannot copy selected nodes";
+   }
+ }
+
 
 void
 FlowScene::
@@ -600,11 +765,11 @@ sendConnectionCreatedToNodes(Connection const& c)
   Node* from = c.getNode(PortType::Out);
   Node* to   = c.getNode(PortType::In);
 
-  Q_ASSERT(from != nullptr);
-  Q_ASSERT(to != nullptr);
+  if(from)
+    from->nodeDataModel()->outputConnectionCreated(c);
 
-  from->nodeDataModel()->outputConnectionCreated(c);
-  to->nodeDataModel()->inputConnectionCreated(c);
+  if(to)
+    to->nodeDataModel()->inputConnectionCreated(c);
 }
 
 
@@ -615,11 +780,11 @@ sendConnectionDeletedToNodes(Connection const& c)
   Node* from = c.getNode(PortType::Out);
   Node* to   = c.getNode(PortType::In);
 
-  Q_ASSERT(from != nullptr);
-  Q_ASSERT(to != nullptr);
+  if(from)
+    from->nodeDataModel()->outputConnectionDeleted(c);
 
-  from->nodeDataModel()->outputConnectionDeleted(c);
-  to->nodeDataModel()->inputConnectionDeleted(c);
+  if(to)
+    to->nodeDataModel()->inputConnectionDeleted(c);
 }
 
 
diff --git a/src/FlowView.cpp b/src/FlowView.cpp
index c15af16..94fcc17 100644
--- a/src/FlowView.cpp
+++ b/src/FlowView.cpp
@@ -9,7 +9,6 @@
 #include <QtCore/QRectF>
 #include <QtCore/QPointF>
 
-#include <QtOpenGL>
 #include <QtWidgets>
 
 #include <QDebug>
@@ -97,11 +96,24 @@ FlowView::setScene(FlowScene *scene)
   addAction(_deleteSelectionAction);
 }
 
+void FlowView::setReadOnly(bool ro)
+{
+    _deleteSelectionAction->setDisabled(ro);
+    _scene->setReadOnly(ro);
+}
+
+bool FlowView::isReadOnly() const
+{
+    return _scene->isReadOnly();
+}
 
 void
 FlowView::
 contextMenuEvent(QContextMenuEvent *event)
 {
+    // MK : remove context menu to create new nodes
+    QGraphicsView::contextMenuEvent(event);
+  /*
   if (itemAt(event->pos()))
   {
     QGraphicsView::contextMenuEvent(event);
@@ -115,7 +127,7 @@ contextMenuEvent(QContextMenuEvent *event)
   //Add filterbox to the context menu
   auto *txtBox = new QLineEdit(&modelMenu);
 
-  txtBox->setPlaceholderText(QStringLiteral("Filter"));
+  txtBox->setPlaceholderText(QStringLiteral("Search"));
   txtBox->setClearButtonEnabled(true);
 
   auto *txtBoxAction = new QWidgetAction(&modelMenu);
@@ -135,10 +147,41 @@ contextMenuEvent(QContextMenuEvent *event)
   QMap<QString, QTreeWidgetItem*> topLevelItems;
   for (auto const &cat : _scene->registry().categories())
   {
-    auto item = new QTreeWidgetItem(treeView);
-    item->setText(0, cat);
-    item->setData(0, Qt::UserRole, skipText);
-    topLevelItems[cat] = item;
+    // Allows subcategories if separeted by "//"
+    QStringList splittedCategories = cat.split("//");
+
+    if (splittedCategories.count() == 1) {
+       auto item = new QTreeWidgetItem(treeView);
+       item->setText(0, cat);
+       item->setData(0, Qt::UserRole, skipText);
+       topLevelItems[cat] = item;
+    }
+    else {
+       QString partialCategory = splittedCategories.at(0);
+       QTreeWidgetItem* parent = nullptr;
+
+       if (!topLevelItems.contains(partialCategory)) {
+          auto item = new QTreeWidgetItem(treeView);
+          item->setText(0, partialCategory);
+          item->setData(0, Qt::UserRole, partialCategory);
+          topLevelItems[partialCategory] = item;
+          parent = item;
+       }
+       else {
+          parent = topLevelItems[partialCategory];
+       }
+
+       for (int i=1; i<splittedCategories.count(); ++i) {
+          partialCategory += "//" + splittedCategories.at(i);
+
+          auto childItem = new QTreeWidgetItem(parent);
+          childItem->setText(0, splittedCategories.at(i));
+          childItem->setData(0, Qt::UserRole, splittedCategories.at(i));
+          topLevelItems[partialCategory] = childItem;
+
+          parent = childItem;
+       }
+    }
   }
 
   for (auto const &assoc : _scene->registry().registeredModelsCategoryAssociation())
@@ -182,25 +225,40 @@ contextMenuEvent(QContextMenuEvent *event)
     modelMenu.close();
   });
 
+  auto depthSearch = [] (QTreeWidgetItem* item, const QString& text) -> void {
+     auto search = [](QTreeWidgetItem* item, const QString& text, const auto& func) -> bool {
+        if(item->childCount() == 0){
+           const auto modelName = item->data(0, Qt::UserRole).toString();
+           const bool match = modelName.contains(text, Qt::CaseInsensitive);
+           item->setHidden(!match);
+           return match;
+        }
+        else {
+           bool matchAtLeastOneChild = false;
+           for(int i = 0; i<item->childCount(); ++i){
+              matchAtLeastOneChild |= func(item->child(i), text, func);
+           }
+           item->setHidden(!matchAtLeastOneChild);
+           return matchAtLeastOneChild;
+        }
+     };
+
+     search(item, text, search);
+  };
+
   //Setup filtering
-  connect(txtBox, &QLineEdit::textChanged, [&](const QString &text)
+  connect(txtBox, &QLineEdit::textChanged, this, [topLevelItems, depthSearch](const QString &text)
   {
-    for (auto& topLvlItem : topLevelItems)
+    for(auto& topLvlItem : topLevelItems)
     {
-      for (int i = 0; i < topLvlItem->childCount(); ++i)
-      {
-        auto child = topLvlItem->child(i);
-        auto modelName = child->data(0, Qt::UserRole).toString();
-        const bool match = (modelName.contains(text, Qt::CaseInsensitive));
-        child->setHidden(!match);
-      }
+       depthSearch(topLvlItem, text);
     }
   });
 
   // make sure the text box gets focus so the user doesn't have to click on it
   txtBox->setFocus();
 
-  modelMenu.exec(event->globalPos());
+  modelMenu.exec(event->globalPos());*/
 }
 
 
@@ -216,12 +274,38 @@ wheelEvent(QWheelEvent *event)
     return;
   }
 
-  double const d = delta.y() / std::abs(delta.y());
+  /*double const d = delta.y() / std::abs(delta.y());
 
   if (d > 0.0)
     scaleUp();
   else
-    scaleDown();
+    scaleDown();*/
+
+  // RM : move scene/nodes only vertically
+  setSceneRect(sceneRect().translated(0.0, -delta.y()));
+  QGraphicsView::wheelEvent(event);
+  limitNodeToRect();
+}
+
+
+void
+FlowView::
+limitNodeToRect()
+{
+    Node* rightNode = scene()->allNodes().at(0);
+    if(scene()->allNodes().at(1)->nodeGraphicsObject().ref())
+        rightNode = scene()->allNodes().at(1);
+    QPointF rightNodePos = rightNode->nodeGraphicsObject().pos();
+    QRectF rightNodeRect = rightNode->nodeGraphicsObject().boundingRect();
+
+    QRectF sceneRectArea = mapToScene(scene()->views().first()->viewport()->geometry()).boundingRect();
+
+    if(rightNodePos.y() < sceneRectArea.top() + 15)
+        rightNodePos.setY(sceneRectArea.top() + 15);
+    if(rightNodePos.y() + rightNodeRect.height() > sceneRectArea.bottom())
+        rightNodePos.setY(sceneRectArea.bottom() - rightNodeRect.height());
+
+    scene()->setNodePosition(*rightNode,rightNodePos);
 }
 
 
@@ -259,21 +343,42 @@ deleteSelectedNodes()
   // Delete the selected connections first, ensuring that they won't be
   // automatically deleted when selected nodes are deleted (deleting a node
   // deletes some connections as well)
-  for (QGraphicsItem * item : _scene->selectedItems())
+  /*for (QGraphicsItem * item : _scene->selectedItems())
   {
     if (auto c = qgraphicsitem_cast<ConnectionGraphicsObject*>(item))
       _scene->deleteConnection(c->connection());
+  }*/
+
+  // MK : disable delete of preview
+  int i = 0;
+  while(i < _scene->selectedItems().size())
+  {
+      QGraphicsItem* item = _scene->selectedItems().at(i);
+      if (auto c = qgraphicsitem_cast<ConnectionGraphicsObject*>(item))
+      {
+          // MK : disable delete of preview
+          if(!c->connection().connectionState().isAPreview())
+          {
+              _scene->deleteConnection(c->connection());
+              i = 0;
+          }
+      }
+      else
+      {
+          ++i;
+      }
   }
 
   // Delete the nodes; this will delete many of the connections.
   // Selected connections were already deleted prior to this loop, otherwise
   // qgraphicsitem_cast<NodeGraphicsObject*>(item) could be a use-after-free
   // when a selected connection is deleted by deleting the node.
-  for (QGraphicsItem * item : _scene->selectedItems())
+  // MK : disable delete nodes !
+  /*for (QGraphicsItem * item : _scene->selectedItems())
   {
     if (auto n = qgraphicsitem_cast<NodeGraphicsObject*>(item))
       _scene->removeNode(n->node());
-  }
+  }*/
 }
 
 
@@ -281,15 +386,30 @@ void
 FlowView::
 keyPressEvent(QKeyEvent *event)
 {
-  switch (event->key())
+  // MK : remove rubberBand
+  /*switch (event->key())
   {
     case Qt::Key_Shift:
       setDragMode(QGraphicsView::RubberBandDrag);
       break;
 
+    case Qt::Key_C:
+       if (event->modifiers() & Qt::ControlModifier) {
+          copy();
+          return;
+       }
+       break;
+
+    case Qt::Key_V:
+       if (event->modifiers() & Qt::ControlModifier) {
+          paste();
+          return;
+       }
+       break;
+
     default:
       break;
-  }
+  }*/
 
   QGraphicsView::keyPressEvent(event);
 }
@@ -299,7 +419,8 @@ void
 FlowView::
 keyReleaseEvent(QKeyEvent *event)
 {
-  switch (event->key())
+  // MK : remove rubberBand
+  /*switch (event->key())
   {
     case Qt::Key_Shift:
       setDragMode(QGraphicsView::ScrollHandDrag);
@@ -307,7 +428,7 @@ keyReleaseEvent(QKeyEvent *event)
 
     default:
       break;
-  }
+  }*/
   QGraphicsView::keyReleaseEvent(event);
 }
 
@@ -335,7 +456,10 @@ mouseMoveEvent(QMouseEvent *event)
     if ((event->modifiers() & Qt::ShiftModifier) == 0)
     {
       QPointF difference = _clickPos - mapToScene(event->pos());
-      setSceneRect(sceneRect().translated(difference.x(), difference.y()));
+      //setSceneRect(sceneRect().translated(difference.x(), difference.y()));
+      setSceneRect(sceneRect().translated(0.0, difference.y())); // Vertical move only
+
+      limitNodeToRect();
     }
   }
 }
@@ -406,5 +530,35 @@ FlowScene *
 FlowView::
 scene()
 {
-  return _scene;
+   return _scene;
+}
+
+QString FlowView::nodeMimeType() const
+{
+   return "application/x-nodeeditor-nodes";
+}
+
+void FlowView::copy()
+{
+   QClipboard *clipboard = QApplication::clipboard();
+   QMimeData *mimeData = new QMimeData();
+
+   QByteArray data = scene()->copyNodes(scene()->selectedNodes());
+   mimeData->setData(nodeMimeType(), data);
+   mimeData->setText(data);
+
+   clipboard->setMimeData(mimeData);
+}
+
+void FlowView::paste()
+{
+   const QClipboard *clipboard = QApplication::clipboard();
+   const QMimeData *mimeData = clipboard->mimeData();
+
+   auto mousePos = mapToScene(mapFromGlobal(QCursor::pos()));
+   if (mimeData->hasFormat(nodeMimeType())) {
+      scene()->pasteNodes(mimeData->data(nodeMimeType()), mousePos);
+   } else if (mimeData->hasText()) {
+      scene()->pasteNodes(mimeData->text().toUtf8(), mousePos);
+   }
 }
diff --git a/src/FlowViewStyle.cpp b/src/FlowViewStyle.cpp
index e08cf4f..7516e1c 100644
--- a/src/FlowViewStyle.cpp
+++ b/src/FlowViewStyle.cpp
@@ -12,7 +12,7 @@
 
 using QtNodes::FlowViewStyle;
 
-inline void initResources() { Q_INIT_RESOURCE(resources); }
+inline void initResources() { Q_INIT_RESOURCE(nodeeditor); }
 
 FlowViewStyle::
 FlowViewStyle()
diff --git a/src/Node.cpp b/src/Node.cpp
index 8ad34c3..b42755a 100644
--- a/src/Node.cpp
+++ b/src/Node.cpp
@@ -25,7 +25,12 @@ using QtNodes::PortType;
 
 Node::
 Node(std::unique_ptr<NodeDataModel> && dataModel)
-  : _uid(QUuid::createUuid())
+  : Node(std::move(dataModel), QUuid::createUuid())
+{}
+
+Node::
+Node(std::unique_ptr<NodeDataModel> && dataModel, QUuid&& uuid)
+  : _uid(std::move(uuid))
   , _nodeDataModel(std::move(dataModel))
   , _nodeState(_nodeDataModel)
   , _nodeGeometry(_nodeDataModel)
@@ -39,6 +44,15 @@ Node(std::unique_ptr<NodeDataModel> && dataModel)
 
   connect(_nodeDataModel.get(), &NodeDataModel::embeddedWidgetSizeUpdated,
           this, &Node::onNodeSizeUpdated );
+
+  connect(_nodeDataModel.get(), &NodeDataModel::portAdded,
+          this, &Node::onPortAdded);
+
+  connect(_nodeDataModel.get(), &NodeDataModel::portMoved,
+          this, &Node::onPortMoved);
+
+  connect(_nodeDataModel.get(), &NodeDataModel::portRemoved,
+          this, &Node::onPortRemoved);
 }
 
 
@@ -95,9 +109,9 @@ reactToPossibleConnection(PortType reactingPortType,
 {
   QTransform const t = _nodeGraphicsObject->sceneTransform();
 
-  QPointF p = t.inverted().map(scenePoint);
+  QPointF nodePoint = t.inverted().map(scenePoint);
 
-  _nodeGeometry.setDraggingPosition(p);
+  _nodeGeometry.setDraggingPosition(nodePoint);
 
   _nodeGraphicsObject->update();
 
@@ -184,50 +198,179 @@ nodeDataModel() const
 
 void
 Node::
-propagateData(std::shared_ptr<NodeData> nodeData,
-              PortIndex inPortIndex) const
+propagateData(PortIndex inPortIndex) const
 {
+  NodeState const& state = nodeState();
+  NodeState::ConnectionPtrSet connections = state.connections(PortType::In, inPortIndex);
+
+  std::vector<std::shared_ptr<NodeData>> nodeData;
+  nodeData.reserve(connections.size());
+  for (const auto& connection : connections)
+  {
+    if (Connection* c = connection.second)
+    {
+      Node* outNode = c->getNode(PortType::Out);
+      PortIndex outNodeIndex = c->getPortIndex(PortType::Out);
+      std::shared_ptr<NodeData> outData = outNode->nodeDataModel()->outData(outNodeIndex);
+      auto& converter = c->typeConverter();
+      if (converter != nullptr)
+      {
+        outData = converter(outData);
+      }
+      nodeData.push_back(outData);
+    }
+  }
+
   _nodeDataModel->setInData(std::move(nodeData), inPortIndex);
 
   //Recalculate the nodes visuals. A data change can result in the node taking more space than before, so this forces a recalculate+repaint on the affected node
-  _nodeGraphicsObject->setGeometryChanged();
+  updateGraphics();
+}
+
+void
+Node::
+propagateData(const QtNodes::Connection* c,
+              std::shared_ptr<NodeData> nodeData,
+              PortIndex inPortIndex) const
+{
+  _nodeDataModel->setInData(c, std::move(nodeData), inPortIndex);
+
+  // MK : Recalculate the nodes visuals. A data change can result in the node taking more space than before, so this forces a recalculate+repaint on the affected node
+  /*_nodeGraphicsObject->setGeometryChanged();
   _nodeGeometry.recalculateSize();
   _nodeGraphicsObject->update();
-  _nodeGraphicsObject->moveConnections();
+  _nodeGraphicsObject->moveConnections();*/
 }
 
-
 void
 Node::
 onDataUpdated(PortIndex index)
 {
-  auto nodeData = _nodeDataModel->outData(index);
-
-  auto connections =
-    _nodeState.connections(PortType::Out, index);
-
+  auto connections = _nodeState.connections(PortType::Out, index);
   for (auto const & c : connections)
-    c.second->propagateData(nodeData);
+  {
+    if (c.second)
+      c.second->propagateData();
+  }
 }
 
 void
 Node::
 onNodeSizeUpdated()
 {
-    if( nodeDataModel()->embeddedWidget() )
-    {
-        nodeDataModel()->embeddedWidget()->adjustSize();
-    }
-    nodeGeometry().recalculateSize();
-    for(PortType type: {PortType::In, PortType::Out})
+  if (nodeDataModel()->embeddedWidget())
+  {
+    nodeDataModel()->embeddedWidget()->adjustSize();
+  }
+  nodeGeometry().recalculateSize();
+  _nodeGraphicsObject->moveConnections();
+}
+
+void
+Node::
+updateGraphics() const
+{
+  _nodeGraphicsObject->setGeometryChanged();
+  _nodeGeometry.recalculateSize();
+  _nodeGraphicsObject->update();
+  _nodeGraphicsObject->moveConnections();
+}
+
+void
+Node::
+insertEntry(PortType portType, PortIndex index)
+{
+  // Insert new port
+  auto& entries = _nodeState.getEntries(portType);
+  entries.insert(entries.begin() + index, NodeState::ConnectionPtrSet());
+
+  // Move subsequent port indices up by one
+  for (int i = index + 1; i < static_cast<int>(entries.size()); ++i)
+  {
+    for (const auto& value : entries[i])
     {
-        for(auto& conn_set : nodeState().getEntries(type))
+      if (Connection* connection = value.second)
+      {
+        Node* node = connection->getNode(portType);
+        if (node)
         {
-            for(auto& pair: conn_set)
-            {
-                Connection* conn = pair.second;
-                conn->getConnectionGraphicsObject().move();
-            }
+           PortIndex newIndex = connection->getPortIndex(portType) + 1;
+           connection->setNodeToPort(*node, portType, newIndex);
         }
+      }
     }
+  }
+}
+
+void
+Node::
+eraseEntry(PortType portType, PortIndex index)
+{
+  auto& entries = _nodeState.getEntries(portType);
+  entries.erase(entries.begin() + index);
+
+  // Move subsequent port indices down by one
+  for (int i = index; i < static_cast<int>(entries.size()); ++i)
+  {
+    for (const auto& value : entries[i])
+    {
+       if (Connection* connection = value.second)
+       {
+          Node* node = connection->getNode(portType);
+          if (node)
+          {
+            PortIndex newIndex = connection->getPortIndex(portType) - 1;
+            connection->setNodeToPort(*node, portType, newIndex);
+          }
+       }
+    }
+  }
+}
+
+void
+Node::
+onPortAdded(PortType portType, PortIndex index)
+{
+  insertEntry(portType, index);
+
+  updateGraphics();
+}
+
+void
+Node::
+onPortMoved(PortType portType, PortIndex oldIndex, PortIndex newIndex)
+{
+  auto& entries = _nodeState.getEntries(portType);
+  auto connections = entries[oldIndex];
+
+  eraseEntry(portType, oldIndex);
+  insertEntry(portType, newIndex);
+
+  updateGraphics();
+}
+
+void
+Node::
+onPortRemoved(PortType portType, PortIndex index)
+{
+  // Remove connections to this port
+  auto& entries = _nodeState.getEntries(portType);
+  int nPorts = _nodeDataModel->nPorts(portType);
+  for (int i = nPorts; i < static_cast<int>(entries.size()); ++i)
+  {
+     std::vector<Connection*> connections;
+     for (const auto& value : entries[index]){
+        if(Connection* connection = value.second){
+           connections.push_back(connection);
+        }
+     }
+
+     // connections may be removed from entries in connectionRemoved()
+     for (Connection* connection : connections)
+       Q_EMIT connectionRemoved(*connection);
+  }
+
+  eraseEntry(portType, index);
+
+  updateGraphics();
 }
diff --git a/src/NodeConnectionInteraction.cpp b/src/NodeConnectionInteraction.cpp
index fb701be..71346d9 100644
--- a/src/NodeConnectionInteraction.cpp
+++ b/src/NodeConnectionInteraction.cpp
@@ -1,3 +1,5 @@
+#include <QQueue>
+
 #include "NodeConnectionInteraction.hpp"
 
 #include "ConnectionGraphicsObject.hpp"
@@ -32,7 +34,6 @@ canConnect(PortIndex &portIndex, TypeConverter & converter) const
 
   PortType requiredPort = connectionRequiredPort();
 
-
   if (requiredPort == PortType::None)
   {
     return false;
@@ -44,6 +45,43 @@ canConnect(PortIndex &portIndex, TypeConverter & converter) const
   if (node == _node)
     return false;
 
+  // 1.6) Check for Cyclic Connection
+  // Fix #198
+  if (node) {
+    auto isConnected = [](Node* a, Node* b) {
+     QQueue<Connection*> cons;
+     QQueue<Node*> nodes;
+     nodes.enqueue(a);
+     while (!nodes.isEmpty()) {
+      auto curNode = nodes.dequeue();
+      auto& curNodeState = curNode->nodeState();
+      auto curNodeCons = curNodeState.getEntries(PortType::Out);
+
+      for (auto& nodeCons : curNodeCons) {
+       for (auto& nodeCon : nodeCons) {
+        cons.enqueue(nodeCon.second);
+       }
+         }
+         while (!cons.isEmpty()) {
+          auto curCon = cons.dequeue();
+          if (auto conNode = curCon->getNode(PortType::In)) {
+             if (conNode == b) return true;
+             
+               nodes.enqueue(conNode);
+            }
+         }
+      }
+      return false;
+    };
+    if (requiredPort == PortType::Out) {
+      if (isConnected(node, _node)) {
+         return false;
+      }
+    } else if (isConnected(_node, node)) {
+       return false;
+    }
+  }
+
   // 2) connection point is on top of the node port
 
   QPointF connectionPoint = connectionEndScenePosition(requiredPort);
@@ -58,11 +96,41 @@ canConnect(PortIndex &portIndex, TypeConverter & converter) const
 
   // 3) Node port is vacant
 
+  // MK : modification to enable in port accept multiple connection
   // port should be empty
-  if (!nodePortIsEmpty(requiredPort, portIndex))
-    return false;
+  /*if (!nodePortIsEmpty(requiredPort, portIndex))
+    return false;*/
+
+  // 4) connection doesn't exist
+
+  const int myStartPortIndex = _connection->getPortIndex(oppositePort(requiredPort));
+
+  if(_node->nodeState().getEntries(requiredPort).size() > static_cast<size_t>(portIndex))
+  {
+      auto existingConnections = _node->nodeState().connections(requiredPort, portIndex);
+
+      auto begin = existingConnections.begin();
+      auto end = existingConnections.end();
+
+      while(begin != end)
+      {
+          if(!(*begin).second->connectionState().isAPreview())
+          {
+              Node* currentNode = (*begin).second->getNode(requiredPort);
+
+              if(currentNode == _node) {
+                  const int startPortIndex = (*begin).second->getPortIndex(oppositePort(requiredPort));
 
-  // 4) Connection type equals node port type, or there is a registered type conversion that can translate between the two
+                  if(startPortIndex == myStartPortIndex)
+                      return false;
+              }
+          }
+
+          ++begin;
+      }
+  }
+
+  // 5) Connection type equals node port type, or there is a registered type conversion that can translate between the two
 
   auto connectionDataType =
     _connection->dataType(oppositePort(requiredPort));
@@ -81,10 +149,20 @@ canConnect(PortIndex &portIndex, TypeConverter & converter) const
       converter = _scene->registry().getTypeConverter(candidateNodeDataType , connectionDataType);
     }
 
-    return (converter != nullptr);
+    if(converter == nullptr)
+        return false;
+
+    if(requiredPort == PortType::In)
+      return modelTarget->acceptInData(converter(node->nodeDataModel()->outData(myStartPortIndex)), portIndex);
+
+    return node->nodeDataModel()->acceptInData(converter(modelTarget->outData(portIndex)), myStartPortIndex);
   }
 
-  return true;
+  // 6) node data model accept it
+  if(requiredPort == PortType::In)
+    return modelTarget->acceptInData(node->nodeDataModel()->outData(myStartPortIndex), portIndex);
+
+  return node->nodeDataModel()->acceptInData(modelTarget->outData(portIndex), myStartPortIndex);
 }
 
 
@@ -149,7 +227,7 @@ disconnect(PortType portToDisconnect) const
   NodeState &state = _node->nodeState();
 
   // clear pointer to Connection in the NodeState
-  state.getEntries(portToDisconnect)[portIndex].clear();
+  state.getEntries(portToDisconnect)[portIndex].erase(_connection->id());
 
   // 4) Propagate invalid data to IN node
   _connection->propagateEmptyData();
@@ -219,6 +297,7 @@ nodePortIndexUnderScenePoint(PortType portType,
   PortIndex portIndex = nodeGeom.checkHitScenePoint(portType,
                                                     scenePoint,
                                                     sceneTransform);
+
   return portIndex;
 }
 
@@ -227,12 +306,20 @@ bool
 NodeConnectionInteraction::
 nodePortIsEmpty(PortType portType, PortIndex portIndex) const
 {
+  if (portType == PortType::None)
+  {
+    return false;
+  }
+
   NodeState const & nodeState = _node->nodeState();
 
   auto const & entries = nodeState.getEntries(portType);
 
-  if (entries[portIndex].empty()) return true;
+  if (entries[portIndex].empty())
+    return true;
+
+  if (portType == PortType::In)
+    return _node->nodeDataModel()->portInConnectionPolicy(portIndex) == NodeDataModel::ConnectionPolicy::Many;
 
-  const auto outPolicy = _node->nodeDataModel()->portOutConnectionPolicy(portIndex);
-  return ( portType == PortType::Out && outPolicy == NodeDataModel::ConnectionPolicy::Many);
+  return _node->nodeDataModel()->portOutConnectionPolicy(portIndex) == NodeDataModel::ConnectionPolicy::Many;
 }
diff --git a/src/NodeConnectionInteraction.hpp b/src/NodeConnectionInteraction.hpp
index fca4e13..bb58cfe 100644
--- a/src/NodeConnectionInteraction.hpp
+++ b/src/NodeConnectionInteraction.hpp
@@ -25,37 +25,46 @@ public:
   /// 2) Connection's vacant end is above the node port
   /// 3) Node port is vacant
   /// 4) Connection type equals node port type, or there is a registered type conversion that can translate between the two
-  bool canConnect(PortIndex & portIndex, 
-                  TypeConverter & converter) const;
+  bool
+  canConnect(PortIndex & portIndex,
+             TypeConverter & converter) const;
 
   /// 1)   Check conditions from 'canConnect'
   /// 1.5) If the connection is possible but a type conversion is needed, add a converter node to the scene, and connect it properly
+  /// 1.6) Check for cyclic connection.
   /// 2)   Assign node to required port in Connection
   /// 3)   Assign Connection to empty port in NodeState
   /// 4)   Adjust Connection geometry
   /// 5)   Poke model to initiate data transfer
-  bool tryConnect() const;
-
+  bool
+  tryConnect() const;
 
   /// 1) Node and Connection should be already connected
   /// 2) If so, clear Connection entry in the NodeState
   /// 3) Propagate invalid data to IN node
   /// 4) Set Connection end to 'requiring a port'
-  bool disconnect(PortType portToDisconnect) const;
+  bool
+  disconnect(PortType portToDisconnect) const;
 
 private:
 
-  PortType connectionRequiredPort() const;
+  PortType
+  connectionRequiredPort() const;
+  
+  QPointF connectionStartScenePosition(PortType) const;
 
   QPointF connectionEndScenePosition(PortType) const;
 
-  QPointF nodePortScenePosition(PortType portType,
-                                PortIndex portIndex) const;
+  QPointF
+  nodePortScenePosition(PortType portType,
+                        PortIndex portIndex) const;
 
-  PortIndex nodePortIndexUnderScenePoint(PortType portType,
-                                         QPointF const &p) const;
+  PortIndex
+  nodePortIndexUnderScenePoint(PortType portType,
+                               QPointF const &p) const;
 
-  bool nodePortIsEmpty(PortType portType, PortIndex portIndex) const;
+  bool
+  nodePortIsEmpty(PortType portType, PortIndex portIndex) const;
 
 private:
 
diff --git a/src/NodeDataModel.cpp b/src/NodeDataModel.cpp
index 9737b34..2a89ba6 100644
--- a/src/NodeDataModel.cpp
+++ b/src/NodeDataModel.cpp
@@ -4,10 +4,15 @@
 
 using QtNodes::NodeDataModel;
 using QtNodes::NodeStyle;
+using QtNodes::NodeData;
+using QtNodes::PortIndex;
+using QtNodes::PortType;
 
 NodeDataModel::
 NodeDataModel()
-  : _nodeStyle(StyleCollection::nodeStyle())
+  : _nodeStyle(StyleCollection::nodeStyle()),
+    _inDataValidator(nullptr),
+    _inDataSetter(nullptr)
 {
   // Derived classes can initialize specific style here
 }
@@ -21,10 +26,48 @@ save() const
 
   modelJson["name"] = name();
 
+  // if ports are dynamics, write their value when saved.
+  // when restored, model need to update the dynamic value.
+
+  if(hasDynamicPorts(PortType::In))
+  {
+     modelJson["dynamic_inputs"]  = static_cast<int>(nPorts(PortType::In));
+  }
+
+  if(hasDynamicPorts(PortType::Out))
+  {
+     modelJson["dynamic_outputs"]  = static_cast<int>(nPorts(PortType::Out));
+  }
+
   return modelJson;
 }
 
 
+NodeDataModel::ConnectionPolicy
+NodeDataModel::
+portConnectionPolicy(PortType portType, PortIndex portIndex) const
+{
+  ConnectionPolicy result = ConnectionPolicy::One;
+
+  switch (portType)
+  {
+    case PortType::In:
+      result = portInConnectionPolicy(portIndex);
+      break;
+
+    case PortType::Out:
+      result = portOutConnectionPolicy(portIndex);
+      break;
+
+    case PortType::None:
+    default:
+      break;
+  }
+
+  return result;
+}
+
+
 NodeStyle const&
 NodeDataModel::
 nodeStyle() const
@@ -39,3 +82,21 @@ setNodeStyle(NodeStyle const& style)
 {
   _nodeStyle = style;
 }
+
+
+void
+NodeDataModel::
+setInData(std::vector<std::shared_ptr<NodeData> > nodeData, PortIndex port)
+{
+  if (portInConnectionPolicy(port) == QtNodes::NodeDataModel::ConnectionPolicy::One)
+  {
+    if (nodeData.empty())
+      setInData(nullptr, port);
+    else
+      setInData(nodeData[0], port);
+  }
+  else
+  {
+    Q_ASSERT(false);
+  }
+}
diff --git a/src/NodeGeometry.cpp b/src/NodeGeometry.cpp
index 9a215bf..22c8db9 100644
--- a/src/NodeGeometry.cpp
+++ b/src/NodeGeometry.cpp
@@ -24,7 +24,7 @@ NodeGeometry(std::unique_ptr<NodeDataModel> const &dataModel)
   , _inputPortWidth(70)
   , _outputPortWidth(70)
   , _entryHeight(20)
-  , _spacing(20)
+  , _spacing(8)
   , _hovered(false)
   , _nSources(dataModel->nPorts(PortType::Out))
   , _nSinks(dataModel->nPorts(PortType::In))
@@ -356,8 +356,7 @@ portWidth(PortType portType) const
       name = _dataModel->dataType(portType, i).name;
     }
 
-    width = std::max(unsigned(_fontMetrics.width(name)),
-                     width);
+    width = std::max(static_cast<unsigned>(_fontMetrics.horizontalAdvance(name)), width);
   }
 
   return width;
diff --git a/src/NodeGraphicsObject.cpp b/src/NodeGraphicsObject.cpp
index efa473a..f51d9a1 100644
--- a/src/NodeGraphicsObject.cpp
+++ b/src/NodeGraphicsObject.cpp
@@ -42,18 +42,20 @@ NodeGraphicsObject(FlowScene &scene,
 
   auto const &nodeStyle = node.nodeDataModel()->nodeStyle();
 
-  {
+  // MK : change style
+  /*{
     auto effect = new QGraphicsDropShadowEffect;
     effect->setOffset(4, 4);
     effect->setBlurRadius(20);
     effect->setColor(nodeStyle.ShadowColor);
 
     setGraphicsEffect(effect);
-  }
+  }*/
 
   setOpacity(nodeStyle.Opacity);
 
-  setAcceptHoverEvents(true);
+  // MK : change style
+  //setAcceptHoverEvents(true);
 
   setZValue(0);
 
@@ -200,7 +202,12 @@ void
 NodeGraphicsObject::
 mousePressEvent(QGraphicsSceneMouseEvent * event)
 {
-  if (_locked)
+  /*
+  PLR : 07/05/2024 --- Bug #419 : in results configuration graphic window error
+  Following code is commented out to disable mouse press event
+
+  // MK : add read only property check
+  if (_locked || _scene.isReadOnly())
     return;
 
   // deselect all other items after this one is selected
@@ -216,8 +223,8 @@ mousePressEvent(QGraphicsSceneMouseEvent * event)
 
     // TODO do not pass sceneTransform
     int const portIndex = nodeGeometry.checkHitScenePoint(portToCheck,
-                                                    event->scenePos(),
-                                                    sceneTransform());
+                                                          event->scenePos(),
+                                                          sceneTransform());
 
     if (portIndex != INVALID)
     {
@@ -271,6 +278,9 @@ mousePressEvent(QGraphicsSceneMouseEvent * event)
   {
     state.setResizing(true);
   }
+
+  End PLR : 07/05/2024 --- Bug #419
+  */
 }
 
 
@@ -278,12 +288,17 @@ void
 NodeGraphicsObject::
 mouseMoveEvent(QGraphicsSceneMouseEvent * event)
 {
-  auto & geom  = _node.nodeGeometry();
+    if(_scene.isReadOnly())
+        return;
+
+  //auto & geom  = _node.nodeGeometry();
   auto & state = _node.nodeState();
 
+  // MK : we do not resize
   if (state.resizing())
   {
-    auto diff = event->pos() - event->lastPos();
+    return;
+    /*auto diff = event->pos() - event->lastPos();
 
     if (auto w = _node.nodeDataModel()->embeddedWidget())
     {
@@ -305,11 +320,28 @@ mouseMoveEvent(QGraphicsSceneMouseEvent * event)
       moveConnections();
 
       event->accept();
-    }
+    }*/
   }
   else
   {
-    QGraphicsObject::mouseMoveEvent(event);
+    //QGraphicsObject::mouseMoveEvent(event);
+
+    // RM : Move nodes only on y-axis
+    auto diff = event->pos() - event->lastPos();
+
+    if(_ref) // We limit the position of the reference Node only
+    {
+        QRectF sceneRectArea = _scene.views().first()->mapToScene(_scene.views().first()->viewport()->geometry()).boundingRect();
+
+        if(pos().y() < sceneRectArea.top() + 15)
+            setPos(pos().x(), sceneRectArea.top() + 15);
+        else if(pos().y() + boundingRect().height() > sceneRectArea.bottom())
+            setPos(pos().x(), sceneRectArea.bottom() - boundingRect().height());
+        else
+            moveBy(0.0,diff.y());
+    }
+    else
+        moveBy(0.0,diff.y());
 
     if (event->lastPos() != event->pos())
       moveConnections();
@@ -329,6 +361,10 @@ void
 NodeGraphicsObject::
 mouseReleaseEvent(QGraphicsSceneMouseEvent* event)
 {
+  /*
+  PLR : 07/05/2024 --- Bug #419 : in results configuration graphic window error
+  Following code is commented out to disable mouse release event
+
   auto & state = _node.nodeState();
 
   state.setResizing(false);
@@ -337,6 +373,15 @@ mouseReleaseEvent(QGraphicsSceneMouseEvent* event)
 
   // position connections precisely after fast node move
   moveConnections();
+
+  // RM : verify which node is selected
+  if(isSelected())
+  {
+      _scene.nodeSelected(node());
+  }
+
+  End PLR : 07/05/2024 --- Bug #419
+  */
 }
 
 
diff --git a/src/NodePainter.cpp b/src/NodePainter.cpp
index c3bdf7a..3425067 100644
--- a/src/NodePainter.cpp
+++ b/src/NodePainter.cpp
@@ -118,7 +118,7 @@ drawConnectionPoints(QPainter* painter,
   float diameter = nodeStyle.ConnectionPointDiameter;
   auto  reducedDiameter = diameter * 0.6;
 
-  for(PortType portType: {PortType::Out, PortType::In})
+  for (PortType portType: {PortType::Out, PortType::In})
   {
     size_t n = state.getEntries(portType).size();
 
@@ -128,16 +128,20 @@ drawConnectionPoints(QPainter* painter,
 
       auto const & dataType = model->dataType(portType, i);
 
-      bool canConnect = (state.getEntries(portType)[i].empty() ||
-                         (portType == PortType::Out &&
-                          model->portOutConnectionPolicy(i) == NodeDataModel::ConnectionPolicy::Many) );
+      // MK : skip connection point that can not be connected
+      if(dataType.id.isEmpty())
+          continue;
+
+      // MK : modification to enable in port accept multiple connection
+      bool canConnect = true;
+      /*bool canConnect = (state.getEntries(portType)[i].empty() ||
+                         model->portConnectionPolicy(portType, i) == NodeDataModel::ConnectionPolicy::Many);*/
 
       double r = 1.0;
       if (state.isReacting() &&
           canConnect &&
           portType == state.reactingPortType())
       {
-
         auto   diff = geom.draggingPos() - p;
         double dist = std::sqrt(QPointF::dotProduct(diff, diff));
         bool   typeConvertable = false;
@@ -157,15 +161,15 @@ drawConnectionPoints(QPainter* painter,
         {
           double const thres = 40.0;
           r = (dist < thres) ?
-                (2.0 - dist / thres ) :
-                1.0;
+              (2.0 - dist / thres ) :
+              1.0;
         }
         else
         {
           double const thres = 80.0;
           r = (dist < thres) ?
-                (dist / thres) :
-                1.0;
+              (dist / thres) :
+              1.0;
         }
       }
 
@@ -182,7 +186,8 @@ drawConnectionPoints(QPainter* painter,
                            reducedDiameter * r,
                            reducedDiameter * r);
     }
-  };
+  }
+
 }
 
 
@@ -198,17 +203,17 @@ drawFilledConnectionPoints(QPainter * painter,
 
   auto diameter = nodeStyle.ConnectionPointDiameter;
 
-  for(PortType portType: {PortType::Out, PortType::In})
+  for (PortType portType: {PortType::Out, PortType::In})
   {
     size_t n = state.getEntries(portType).size();
 
     for (size_t i = 0; i < n; ++i)
     {
-      QPointF p = geom.portScenePosition(i, portType);
+      QPointF p = geom.portScenePosition(static_cast<PortIndex>(i), portType);
 
       if (!state.getEntries(portType)[i].empty())
       {
-        auto const & dataType = model->dataType(portType, i);
+        auto const & dataType = model->dataType(portType, static_cast<PortIndex>(i));
 
         if (connectionStyle.useDataDefinedColors())
         {
@@ -277,7 +282,7 @@ drawEntryLabels(QPainter * painter,
   QFontMetrics const & metrics =
     painter->fontMetrics();
 
-  for(PortType portType: {PortType::Out, PortType::In})
+  for (PortType portType: {PortType::Out, PortType::In})
   {
     auto const &nodeStyle = model->nodeStyle();
 
@@ -287,7 +292,7 @@ drawEntryLabels(QPainter * painter,
 
     for (size_t i = 0; i < n; ++i)
     {
-      QPointF p = geom.portScenePosition(i, portType);
+      QPointF p = geom.portScenePosition(static_cast<PortIndex>(i), portType);
 
       if (entries[i].empty())
         painter->setPen(nodeStyle.FontColorFaded);
@@ -296,13 +301,13 @@ drawEntryLabels(QPainter * painter,
 
       QString s;
 
-      if (model->portCaptionVisible(portType, i))
+      if (model->portCaptionVisible(portType, static_cast<PortIndex>(i)))
       {
-        s = model->portCaption(portType, i);
+        s = model->portCaption(portType, static_cast<PortIndex>(i));
       }
       else
       {
-        s = model->dataType(portType, i).name;
+        s = model->dataType(portType, static_cast<PortIndex>(i)).name;
       }
 
       auto rect = metrics.boundingRect(s);
@@ -311,16 +316,16 @@ drawEntryLabels(QPainter * painter,
 
       switch (portType)
       {
-      case PortType::In:
-        p.setX(5.0);
-        break;
+        case PortType::In:
+          p.setX(5.0);
+          break;
 
-      case PortType::Out:
-        p.setX(geom.width() - 5.0 - rect.width());
-        break;
+        case PortType::Out:
+          p.setX(geom.width() - 5.0 - rect.width());
+          break;
 
-      default:
-        break;
+        default:
+          break;
       }
 
       painter->drawText(p, s);
diff --git a/src/NodeState.cpp b/src/NodeState.cpp
index 226d5cf..38c027c 100644
--- a/src/NodeState.cpp
+++ b/src/NodeState.cpp
@@ -62,7 +62,7 @@ setConnection(PortType portType,
   auto &connections = getEntries(portType);
 
   connections.at(portIndex).insert(std::make_pair(connection.id(),
-                                               &connection));
+                                                  &connection));
 }
 
 
@@ -72,7 +72,10 @@ eraseConnection(PortType portType,
                 PortIndex portIndex,
                 QUuid id)
 {
-  getEntries(portType)[portIndex].erase(id);
+   auto& entry = getEntries(portType);
+   if(portIndex >= 0 && portIndex < static_cast<int>(entry.size())){
+      entry[portIndex].erase(id);
+   }
 }
 
 
diff --git a/src/NodeStyle.cpp b/src/NodeStyle.cpp
index c62e0ac..904257c 100644
--- a/src/NodeStyle.cpp
+++ b/src/NodeStyle.cpp
@@ -14,7 +14,7 @@
 
 using QtNodes::NodeStyle;
 
-inline void initResources() { Q_INIT_RESOURCE(resources); }
+inline void initResources() { Q_INIT_RESOURCE(nodeeditor); }
 
 NodeStyle::
 NodeStyle()
